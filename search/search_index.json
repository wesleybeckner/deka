{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Deka \u00b6 Deka is a project that builds optimum stock cutting patterns for manufacturers Visit the github repo to access all materials and code for this project","title":"About"},{"location":"#deka","text":"Deka is a project that builds optimum stock cutting patterns for manufacturers Visit the github repo to access all materials and code for this project","title":"Deka"},{"location":"exercises/P1_Stock_Cutting/","text":"Stock Cutting Part 1: Finding Good Patterns \u00b6 In this project notebook we'll be laying the foundations of stock cutting. We'll begin by discussing the common dynamic programming problem: the knapsack problem Supporting Material Video (15 mins) 1.0: What is the knapsack Problem? \u00b6 From Wikipedia : The knapsack problem is a problem in combinatorial optimization: Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. It derives its name from the problem faced by someone who is constrained by a fixed-size knapsack and must fill it with the most valuable items. The problem often arises in resource allocation where the decision makers have to choose from a set of non-divisible projects or tasks under a fixed budget or time constraint, respectively. 1.2: Simple Knapsack \u00b6 Say we have the following items we want to fit into a bag. Our total weight limit is 8 lbs. The items are worth 1, 2, 5, and 6 dollars apiece and weigh 2, 3, 4, and 5 lbs. val = [1, 2, 5, 6] wt = [2, 3, 4, 5] W = 8 We may be able to solve in our own minds that the maximum value here is items of value 2 and 6 for a total value of 8 dollars and total weight of 8 lbs. How do we solve this algorithmically? val = [ 1 , 2 , 5 , 6 ] wt = [ 2 , 3 , 4 , 5 ] W = 8 the table we would fill out looks like the following Value Weight 0 1 2 3 4 5 6 7 8 None None 0 0 0 0 0 0 0 0 0 1 2 0 0 1 1 1 1 1 1 1 2 3 0 0 1 2 2 3 3 3 3 5 4 0 0 1 2 5 5 6 6 7 6 5 0 0 1 2 5 6 6 7 8 The column headers (after Value and Weight) indicate the maximum weight allowable under that column. Every row indicates what items are allowable i.e. on row 2 we only consider item 1, on row 3 we consider items 1 and 2, and so forth. Let's walk through a few cells. In the first two columns, we can't include any items under this weight restriction, hence all cell values are 0. In column 2, row 2, we are able to fit item 1 under this weight constraint, so the value of our knapsack increases to 1 In the remaining cells of row 2, our value is persistant at a total of 1, since we are only considering the first item in this row Moving onto the second row, things get interesting at row 3, column 3 if n is our current item, and w is the current weight (i.e. n is the row and w is the column) then we want to fill in the current cell t[n,w] with the maximum value: t[n-1,w] or t[n-1, W-wt[n]] + val[n] Let's make sense of the max statement in 4.B. We know that at the current cell, we can always default to the value of the cell above ( t[n-1,w] ). The trick comes in the second part of the max statement. We look at the total value if we were to add the current item ( val[n] ), to the value back in the table in the previous row [n-1] where the total weight is equal to the current weight under consideration minus the weight of the current item ( W-wt[n] ) Now we'll go into our second point. Take a look at row 4, column 3 (directly below the cell we were considering before) in this case, the weight of the current item (4 lbs) is more than the maximum allowable weight (3 lbs) and so in this case we default to the value in the cell above ( t[n-1, w] ) algorithmically this looks like the following: if wt[n] <= W: return max(t[n-1,w], t[n-1, W-wt[n]] + val[n]) elif wt[n] > W: return t[n-1, w] 1.2.1 Use recursion to find the optimum value of the knapsack \u00b6 The insight we require is that in the above code block, we want to run this conditional on the bottom right corner of the table, where we have allowed the maximum possible weight in the bag and included all items for consideration. But in order to ask this we need to know the values in the preceding cells of the table! This is where recurssion comes in handy. Our recursive algorithm will return t[n][w] for the given parameters of wt (weights), val (values), W (max allowable weight), and, well t , the table itself. \ud83c\udf92 Exercise 1: Create the empty table as a list of lists \u00b6 Before writing the knapsack function, we will need to initialize our empty table: # We initialize the table. note that I am adding a 0th row and a 0th column # at the top and left of the table respectively. The table # needs to be len(val) + 1 rows and W + 1 columns [[None, None, None, None, None, None, None, None, None], [None, None, None, None, None, None, None, None, None], [None, None, None, None, None, None, None, None, None], [None, None, None, None, None, None, None, None, None], [None, None, None, None, None, None, None, None, None]] after you've propery coded out the table wrap this into a function initt # we'll wrap the above into a function for ease of use def initt ( W , val ): pass \ud83c\udf92 Exercise 2: Complete the function knapsack using recursion without memoization \u00b6 Note that we need to think about how our indexing will work between the table, t , and our list representations of our items, wt and val . index 0 in our table means no items and no weight whereas in our list index 0 reprents item 1 so in the following knapsack function we need to shift all our indexing's of wt and val backwards by 1 (this is the difference between the code in the function and the mathematical representation in Section 1.2) def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 # now include the conditionals if wt [ n - 1 ] <= w : pass elif wt [ n - 1 ] > w : pass knapsack ( wt , val , W , len ( val ), t ) 8 If we look at the output of our table, we will see that it matches the one we described in Section 1.2 Value Weight 0 1 2 3 4 5 6 7 8 None None 0 0 0 0 0 0 0 0 0 1 2 0 0 1 1 1 1 1 1 1 2 3 0 0 1 2 2 3 3 3 3 5 4 0 0 1 2 5 5 6 6 7 6 5 0 0 1 2 5 6 6 7 8 it turns out that we did not have to visit every cell in the table however, to arrive at the optimal value of our knapsack: t [[None, None, None, None, None, None, None, None, None], [None, 0, None, 1, 1, 1, None, None, 1], [None, None, None, 2, 2, None, None, None, 3], [None, None, None, 2, None, None, None, None, 7], [None, None, None, None, None, None, None, None, 8]] 1.2.2 Enrichment: use memoization to speed up the solution \u00b6 Memoization is a techniqued used along with recursion to create dynamic programms . We let our recursive algorithm know when we've already visited a subproblem by passing along a table (which in this case, we already have) \ud83c\udf92 Exercise 3: Check if we have already visited a location in the table \u00b6 def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != None : pass # now include the conditionals if wt [ n - 1 ] <= w : pass elif wt [ n - 1 ] > w : pass 1.2.3 Reconstruct what items were added to the knapsack by reading the table \u00b6 The next part of the puzzle is to determine what items were added to the knapsack to achieve this optimal result! We can infer this from the table. Take a look at the table again, the algorithm we will envoke is that if the current cell's value does not appear in the previous row, it is because added that row's item! To see what else is in that hypothetical knapsack, we simply move up a row and left the number of columns equal to the last item we added, and repeat the process \ud83c\udf92 Exercise 4: Complete the pseudo code below to create a set that includes all the items in the knapsack \u00b6 recon = set () column = W # we will iterate through the rows of the table from bottom to top for row in range ( len ( val ))[:: - 1 ]: # we know that if the current cell value is not anywhere in the # previous row, it is because we added that item to the knapsack # remember that the table indexing is shifted forward compared to # the list indexes if t [ row + 1 ][ column ] not in t [ row ]: # after we add the item, we need to adjust the weight the appropriate # number of steps # we will stop after we reach the 0th (no weight) column if column < 0 : pass else : pass recon {1, 3} \ud83c\udf92 Exercise 5: Wrap this in a function called reconstruct \u00b6 we see that the output of the reconstruction are the second and fourth items (index starts at 0), which is what we expected! Let's package this into a function def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if t [ j + 1 ][ W ] not in t [ j ]: if W < 0 : pass else : pass return recon Now, to translate these indices to actual items we're going to use a function called Counter Dict subclass for counting hashable items. Sometimes called a bag or multiset. Elements are stored as dictionary keys and their counts are stored as dictionary values. We'll use Counter along with Numpy to take our indices/val list and count the number of times an item was used in the solution import numpy as np from collections import Counter sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ( np . array ( val )[ list ( sack )]) pattern Counter({2: 1, 6: 1}) 1.3 Unit Tests \u00b6 It is always good practice to test as we go. Let's make sure our algorithm works on some known subproblems def test_small_bag (): # the problem parameters val = [ 60 , 50 , 70 , 30 ] wt = [ 5 , 3 , 4 , 2 ] W = 5 # the known solution max_val = 80 max_items = [ 50 , 30 ] t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ( np . array ( val )[ list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert list ( pattern . keys ()) == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) test_small_bag () Optimal value found Optimal items found def test_val_weight_equality (): # the problem parameters val = wt = [ 2 , 2 , 2 , 2 , 5 , 5 , 5 , 5 ] W = 14 # the known solution max_val = 14 max_items = Counter ([ 5 , 5 , 2 , 2 ]) t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ( np . array ( val )[ list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert pattern == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) test_val_weight_equality () Optimal value found Optimal items found 1.4 Save our functions \u00b6 import numpy as np from collections import Counter def knapsack ( wt , val , W , n , t ): \"\"\" in our particular case, the wt and val of the item are the same wt/val is 's' and is the items sorted by length, increasing wt: list the ordered weights (lengths of the rolls) val: list the ordered values (lengths of the rolls) W: int the weight of the current knapsack (the used length of the mother roll) n: int the number of items in the mother roll t: list of list the knapsack table \"\"\" # base conditions if n == 0 or W == 0 : # the first row and first column of the table is filled with 0s return 0 if t [ n ][ W ] != - 1 : # already solved at [n][W] return t [ n ][ W ] # choice diagram code if wt [ n - 1 ] <= W : # if the previous item under consideration is less than the current # weight left in the mother roll # we can now do 1 of 2 things add the new item in (and take the val # of the bag at the previous lvl w/o the item) (the answer to the left # in the table) plus the new wt/val or we use the best answer from one # fewer items at this weight lvl (the answer above the current cell in # the table) # t[n,w] = max{t[n-1,w], t[n-1, w-w[n-1]] + val[n-1]} # note that in the following wt and val are indexed starting at 0 # but t/knapsack is indexed starting at 1 (index 0 in the table is all # 0's) t [ n ][ W ] = max ( val [ n - 1 ] + knapsack ( wt , val , W - wt [ n - 1 ], n - 1 , t ), knapsack ( wt , val , W , n - 1 , t )) return t [ n ][ W ] elif wt [ n - 1 ] > W : # if wt/val of the current item under consideration is more than the # weight left in the bag, we've already found the best solution for # this number of items t [ n ][ W ] = knapsack ( wt , val , W , n - 1 , t ) return t [ n ][ W ] def initt ( B , lens ): \"\"\" t, the returned table, will be a list of lists, but if transformed to an array it takes the shape of the number of products + 1 (len(s) + 1) by the usable width + 1 (B + 1) \"\"\" # We initialize the matrix with -1 at first. return [[ - 1 for i in range ( B + 1 )] for j in range ( lens + 1 )] def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if t [ j + 1 , W ] not in t [ j ,:]: recon . add ( j ) W = W - wt [ j ] # move columns in table lookup if W < 0 : break else : continue return recon 1.5 Lab \u00b6 In the deka repository add our functions to enginge.py and our unit_tests to test_engine.py make sure you can run the tests via the Makefile","title":"The Knapsack Problem"},{"location":"exercises/P1_Stock_Cutting/#stock-cutting-part-1-finding-good-patterns","text":"In this project notebook we'll be laying the foundations of stock cutting. We'll begin by discussing the common dynamic programming problem: the knapsack problem Supporting Material Video (15 mins)","title":"Stock Cutting Part 1: Finding Good Patterns"},{"location":"exercises/P1_Stock_Cutting/#10-what-is-the-knapsack-problem","text":"From Wikipedia : The knapsack problem is a problem in combinatorial optimization: Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. It derives its name from the problem faced by someone who is constrained by a fixed-size knapsack and must fill it with the most valuable items. The problem often arises in resource allocation where the decision makers have to choose from a set of non-divisible projects or tasks under a fixed budget or time constraint, respectively.","title":"1.0: What is the knapsack Problem?"},{"location":"exercises/P1_Stock_Cutting/#12-simple-knapsack","text":"Say we have the following items we want to fit into a bag. Our total weight limit is 8 lbs. The items are worth 1, 2, 5, and 6 dollars apiece and weigh 2, 3, 4, and 5 lbs. val = [1, 2, 5, 6] wt = [2, 3, 4, 5] W = 8 We may be able to solve in our own minds that the maximum value here is items of value 2 and 6 for a total value of 8 dollars and total weight of 8 lbs. How do we solve this algorithmically? val = [ 1 , 2 , 5 , 6 ] wt = [ 2 , 3 , 4 , 5 ] W = 8 the table we would fill out looks like the following Value Weight 0 1 2 3 4 5 6 7 8 None None 0 0 0 0 0 0 0 0 0 1 2 0 0 1 1 1 1 1 1 1 2 3 0 0 1 2 2 3 3 3 3 5 4 0 0 1 2 5 5 6 6 7 6 5 0 0 1 2 5 6 6 7 8 The column headers (after Value and Weight) indicate the maximum weight allowable under that column. Every row indicates what items are allowable i.e. on row 2 we only consider item 1, on row 3 we consider items 1 and 2, and so forth. Let's walk through a few cells. In the first two columns, we can't include any items under this weight restriction, hence all cell values are 0. In column 2, row 2, we are able to fit item 1 under this weight constraint, so the value of our knapsack increases to 1 In the remaining cells of row 2, our value is persistant at a total of 1, since we are only considering the first item in this row Moving onto the second row, things get interesting at row 3, column 3 if n is our current item, and w is the current weight (i.e. n is the row and w is the column) then we want to fill in the current cell t[n,w] with the maximum value: t[n-1,w] or t[n-1, W-wt[n]] + val[n] Let's make sense of the max statement in 4.B. We know that at the current cell, we can always default to the value of the cell above ( t[n-1,w] ). The trick comes in the second part of the max statement. We look at the total value if we were to add the current item ( val[n] ), to the value back in the table in the previous row [n-1] where the total weight is equal to the current weight under consideration minus the weight of the current item ( W-wt[n] ) Now we'll go into our second point. Take a look at row 4, column 3 (directly below the cell we were considering before) in this case, the weight of the current item (4 lbs) is more than the maximum allowable weight (3 lbs) and so in this case we default to the value in the cell above ( t[n-1, w] ) algorithmically this looks like the following: if wt[n] <= W: return max(t[n-1,w], t[n-1, W-wt[n]] + val[n]) elif wt[n] > W: return t[n-1, w]","title":"1.2: Simple Knapsack"},{"location":"exercises/P1_Stock_Cutting/#121-use-recursion-to-find-the-optimum-value-of-the-knapsack","text":"The insight we require is that in the above code block, we want to run this conditional on the bottom right corner of the table, where we have allowed the maximum possible weight in the bag and included all items for consideration. But in order to ask this we need to know the values in the preceding cells of the table! This is where recurssion comes in handy. Our recursive algorithm will return t[n][w] for the given parameters of wt (weights), val (values), W (max allowable weight), and, well t , the table itself.","title":"1.2.1 Use recursion to find the optimum value of the knapsack"},{"location":"exercises/P1_Stock_Cutting/#exercise-1-create-the-empty-table-as-a-list-of-lists","text":"Before writing the knapsack function, we will need to initialize our empty table: # We initialize the table. note that I am adding a 0th row and a 0th column # at the top and left of the table respectively. The table # needs to be len(val) + 1 rows and W + 1 columns [[None, None, None, None, None, None, None, None, None], [None, None, None, None, None, None, None, None, None], [None, None, None, None, None, None, None, None, None], [None, None, None, None, None, None, None, None, None], [None, None, None, None, None, None, None, None, None]] after you've propery coded out the table wrap this into a function initt # we'll wrap the above into a function for ease of use def initt ( W , val ): pass","title":"\ud83c\udf92 Exercise 1: Create the empty table as a list of lists"},{"location":"exercises/P1_Stock_Cutting/#exercise-2-complete-the-function-knapsack-using-recursion-without-memoization","text":"Note that we need to think about how our indexing will work between the table, t , and our list representations of our items, wt and val . index 0 in our table means no items and no weight whereas in our list index 0 reprents item 1 so in the following knapsack function we need to shift all our indexing's of wt and val backwards by 1 (this is the difference between the code in the function and the mathematical representation in Section 1.2) def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 # now include the conditionals if wt [ n - 1 ] <= w : pass elif wt [ n - 1 ] > w : pass knapsack ( wt , val , W , len ( val ), t ) 8 If we look at the output of our table, we will see that it matches the one we described in Section 1.2 Value Weight 0 1 2 3 4 5 6 7 8 None None 0 0 0 0 0 0 0 0 0 1 2 0 0 1 1 1 1 1 1 1 2 3 0 0 1 2 2 3 3 3 3 5 4 0 0 1 2 5 5 6 6 7 6 5 0 0 1 2 5 6 6 7 8 it turns out that we did not have to visit every cell in the table however, to arrive at the optimal value of our knapsack: t [[None, None, None, None, None, None, None, None, None], [None, 0, None, 1, 1, 1, None, None, 1], [None, None, None, 2, 2, None, None, None, 3], [None, None, None, 2, None, None, None, None, 7], [None, None, None, None, None, None, None, None, 8]]","title":"\ud83c\udf92 Exercise 2: Complete the function knapsack using recursion without memoization"},{"location":"exercises/P1_Stock_Cutting/#122-enrichment-use-memoization-to-speed-up-the-solution","text":"Memoization is a techniqued used along with recursion to create dynamic programms . We let our recursive algorithm know when we've already visited a subproblem by passing along a table (which in this case, we already have)","title":"1.2.2 Enrichment: use memoization to speed up the solution"},{"location":"exercises/P1_Stock_Cutting/#exercise-3-check-if-we-have-already-visited-a-location-in-the-table","text":"def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != None : pass # now include the conditionals if wt [ n - 1 ] <= w : pass elif wt [ n - 1 ] > w : pass","title":"\ud83c\udf92 Exercise 3: Check if we have already visited a location in the table"},{"location":"exercises/P1_Stock_Cutting/#123-reconstruct-what-items-were-added-to-the-knapsack-by-reading-the-table","text":"The next part of the puzzle is to determine what items were added to the knapsack to achieve this optimal result! We can infer this from the table. Take a look at the table again, the algorithm we will envoke is that if the current cell's value does not appear in the previous row, it is because added that row's item! To see what else is in that hypothetical knapsack, we simply move up a row and left the number of columns equal to the last item we added, and repeat the process","title":"1.2.3 Reconstruct what items were added to the knapsack by reading the table"},{"location":"exercises/P1_Stock_Cutting/#exercise-4-complete-the-pseudo-code-below-to-create-a-set-that-includes-all-the-items-in-the-knapsack","text":"recon = set () column = W # we will iterate through the rows of the table from bottom to top for row in range ( len ( val ))[:: - 1 ]: # we know that if the current cell value is not anywhere in the # previous row, it is because we added that item to the knapsack # remember that the table indexing is shifted forward compared to # the list indexes if t [ row + 1 ][ column ] not in t [ row ]: # after we add the item, we need to adjust the weight the appropriate # number of steps # we will stop after we reach the 0th (no weight) column if column < 0 : pass else : pass recon {1, 3}","title":"\ud83c\udf92 Exercise 4: Complete the pseudo code below to create a set that includes all the items in the knapsack"},{"location":"exercises/P1_Stock_Cutting/#exercise-5-wrap-this-in-a-function-called-reconstruct","text":"we see that the output of the reconstruction are the second and fourth items (index starts at 0), which is what we expected! Let's package this into a function def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if t [ j + 1 ][ W ] not in t [ j ]: if W < 0 : pass else : pass return recon Now, to translate these indices to actual items we're going to use a function called Counter Dict subclass for counting hashable items. Sometimes called a bag or multiset. Elements are stored as dictionary keys and their counts are stored as dictionary values. We'll use Counter along with Numpy to take our indices/val list and count the number of times an item was used in the solution import numpy as np from collections import Counter sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ( np . array ( val )[ list ( sack )]) pattern Counter({2: 1, 6: 1})","title":"\ud83c\udf92 Exercise 5: Wrap this in a function called reconstruct"},{"location":"exercises/P1_Stock_Cutting/#13-unit-tests","text":"It is always good practice to test as we go. Let's make sure our algorithm works on some known subproblems def test_small_bag (): # the problem parameters val = [ 60 , 50 , 70 , 30 ] wt = [ 5 , 3 , 4 , 2 ] W = 5 # the known solution max_val = 80 max_items = [ 50 , 30 ] t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ( np . array ( val )[ list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert list ( pattern . keys ()) == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) test_small_bag () Optimal value found Optimal items found def test_val_weight_equality (): # the problem parameters val = wt = [ 2 , 2 , 2 , 2 , 5 , 5 , 5 , 5 ] W = 14 # the known solution max_val = 14 max_items = Counter ([ 5 , 5 , 2 , 2 ]) t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ( np . array ( val )[ list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert pattern == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) test_val_weight_equality () Optimal value found Optimal items found","title":"1.3 Unit Tests"},{"location":"exercises/P1_Stock_Cutting/#14-save-our-functions","text":"import numpy as np from collections import Counter def knapsack ( wt , val , W , n , t ): \"\"\" in our particular case, the wt and val of the item are the same wt/val is 's' and is the items sorted by length, increasing wt: list the ordered weights (lengths of the rolls) val: list the ordered values (lengths of the rolls) W: int the weight of the current knapsack (the used length of the mother roll) n: int the number of items in the mother roll t: list of list the knapsack table \"\"\" # base conditions if n == 0 or W == 0 : # the first row and first column of the table is filled with 0s return 0 if t [ n ][ W ] != - 1 : # already solved at [n][W] return t [ n ][ W ] # choice diagram code if wt [ n - 1 ] <= W : # if the previous item under consideration is less than the current # weight left in the mother roll # we can now do 1 of 2 things add the new item in (and take the val # of the bag at the previous lvl w/o the item) (the answer to the left # in the table) plus the new wt/val or we use the best answer from one # fewer items at this weight lvl (the answer above the current cell in # the table) # t[n,w] = max{t[n-1,w], t[n-1, w-w[n-1]] + val[n-1]} # note that in the following wt and val are indexed starting at 0 # but t/knapsack is indexed starting at 1 (index 0 in the table is all # 0's) t [ n ][ W ] = max ( val [ n - 1 ] + knapsack ( wt , val , W - wt [ n - 1 ], n - 1 , t ), knapsack ( wt , val , W , n - 1 , t )) return t [ n ][ W ] elif wt [ n - 1 ] > W : # if wt/val of the current item under consideration is more than the # weight left in the bag, we've already found the best solution for # this number of items t [ n ][ W ] = knapsack ( wt , val , W , n - 1 , t ) return t [ n ][ W ] def initt ( B , lens ): \"\"\" t, the returned table, will be a list of lists, but if transformed to an array it takes the shape of the number of products + 1 (len(s) + 1) by the usable width + 1 (B + 1) \"\"\" # We initialize the matrix with -1 at first. return [[ - 1 for i in range ( B + 1 )] for j in range ( lens + 1 )] def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if t [ j + 1 , W ] not in t [ j ,:]: recon . add ( j ) W = W - wt [ j ] # move columns in table lookup if W < 0 : break else : continue return recon","title":"1.4 Save our functions"},{"location":"exercises/P1_Stock_Cutting/#15-lab","text":"In the deka repository add our functions to enginge.py and our unit_tests to test_engine.py make sure you can run the tests via the Makefile","title":"1.5 Lab"},{"location":"exercises/P2_Stock_Cutting/","text":"Stock Cutting Part 2: Finding Good (But not Best) Patterns \u00b6 In this project notebook we'll be leveraging our solution to the knapsack problem to create viable patterns for stock cutting. 1.0: Import Functions and Libraries \u00b6 from collections import Counter def initt ( W , val ): return [[ None for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )] def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != None : return t [ n ][ w ] # now include the conditionals if wt [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( wt , val , w , n - 1 , t ), knapsack ( wt , val , w - wt [ n - 1 ], n - 1 , t ) + val [ n - 1 ]) return t [ n ][ w ] elif wt [ n - 1 ] > w : t [ n ][ w ] = knapsack ( wt , val , w , n - 1 , t ) return t [ n ][ w ] def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if t [ j + 1 ][ W ] not in t [ j ]: recon . add ( j ) W = W - wt [ j ] # move columns in table lookup if W < 0 : break else : continue return recon def test_small_bag (): # the problem parameters val = [ 60 , 50 , 70 , 30 ] wt = [ 5 , 3 , 4 , 2 ] W = 5 # the known solution max_val = 80 max_items = [ 50 , 30 ] t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert list ( pattern . keys ()) == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_val_weight_equality (): # the problem parameters val = wt = [ 2 , 2 , 2 , 2 , 5 , 5 , 5 , 5 ] W = 14 # the known solution max_val = 14 max_items = Counter ([ 5 , 5 , 2 , 2 ]) t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert pattern == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) test_small_bag () Optimal value found Optimal items found test_val_weight_equality () Optimal value found Optimal items found 1.1 Modifications from knapsack to cutting stock \u00b6 You may have guessed this, but for all of our problems the wt list and val list will always be the same; they will be the list of widths scheduled to cut from stock. When we get our orders, we will need to adjust such that we are solving the appropriate problem with the knapsack function. To give an example, we might have 100 orders to fulfill with slitwidth 170. However we can max only fit 20 on a roll. In this situation, we don't want to include all 100 repeat widths in the knapsack problem, because we know we can't possibly fit that many. Instead, we want to only provide the maximum number of 170's we could possibly fit on a roll. This will make the algorithm more efficient. 1.1.1 Can we simplify the knapsack function? \u00b6 wt = val = [ 170 , 280 , 320 ] W = 4000 t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) pattern Counter({170: 1, 280: 1, 320: 1}) \ud83c\udf92 Exercise 1: replace wt and val in knapsack and nonetype in initt \u00b6 Notice how in the above cell we set wt and val equal to our product widths. In the cell below, rewrite the knapsack function so that widths takes the place of both wt and val def initt ( W , val ): return [[ - 1 for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )] def knapsack ( widths , w , n , t ): # n, w will be the row, column of our table # solve the basecase. pass Do the same thing for the reconstruct function. And while we're at it, let's change N to n and W to w so that our variables are consistent across both functions def reconstruct ( n , w , t , widths ): pass and lets test our new functions widths = [ 170 , 280 , 320 ] W = 4000 t = initt ( W , widths ) best = knapsack ( widths , W , len ( widths ), t ) sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) pattern Counter({170: 1, 280: 1, 320: 1}) 1.1.2 How many slit widths? \u00b6 Does our answer to the knapsack problem above make sense? It does based on what we fed the function. However, in reality what we're looking for is the best pattern given a list of unique slit widths even if that requires repeating units of slit widths. So how do we modify the way we call the function? widths = [ 170 , 280 , 320 ] W = 4000 for w in widths : print ([ w ] * int ( W / w )) [170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170] [280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280] [320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320] \ud83c\udf92 Exercise 2: call knapsack with a modified list of widths \u00b6 In the above, we created new lists that properly signify the maximum number of units we could fit into the stock width. It is this list of items that we wish to feed into our knapsack problem. Rewrite our call to the knapsack problem below Also include neckin when you send this to knapsack widths = [ 170 , 280 , 320 ] neckin = [ 5 , 6 , 7 ] W = 4000 # modify call to knapsack 3999 Counter({175: 3, 327: 8, 286: 3}) \ud83c\udf92 Exercise 3: report the loss \u00b6 As a last adjustment, we want to think of the loss from a pattern, not the total number of millimeters used. Calculate the loss widths = [ 170 , 280 , 320 ] neckin = [ 5 , 6 , 7 ] W = 4000 # modify call to knapsack 1 0.025 Counter({175: 3, 327: 8, 286: 3}) 1.2: Why good but not best? \u00b6 The shortcoming of the knapsack problem is that while it is able to find the best possible configuration to maximize the value of a knapsack, it does not consider constraints around items we must include. That is, when we create a schedule for our stock cutter, it is necessary that we deliver all orders within a reasonable time. To over come this hurdle, we combine results from the knapsack problem (and any other pattern generative algorithm we would like to include) with a linear opimization task. We will cover the linear optimization task in a later notebook. Just know for now that we are still working on creating candidate patterns. 1.2.1 Find all unique combinations of slit widths \u00b6 widths = [ 170 , 280 , 320 ] neckin = [ 5 , 6 , 7 ] W = 4000 # modify call to knapsack # this new list will represent what we actually send to the function knapsack new = [] for w in widths : new += [ w ] * int ( W / w ) widths = new t = initt ( W , widths ) best = knapsack ( widths , W , len ( widths ), t ) loss = W - best print ( loss ) percent = loss / W * 100 print ( percent ) sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) pattern 1 0.025 Counter({175: 3, 327: 8, 286: 3}) \ud83c\udf92 Exercise 4: permutate the list of unique widths \u00b6 from itertools import combinations _widths = [ 170 , 280 , 320 ] W = 4000 max_unique_layouts = 3 def seed_patterns ( _widths , W , max_unique_layouts = 3 ): patterns = [] for current_max in range ( 1 , max_unique_layouts + 1 ): pre_sacks = list ( combinations ( _widths , current_max )) for widths in pre_sacks : # your call to knapsack pass return patterns Call your function seed_patterns ( _widths , W ) [[Counter({170: 23}), 90], [Counter({280: 14}), 80], [Counter({320: 12}), 160], [Counter({170: 12, 280: 7}), 0], [Counter({170: 16, 320: 4}), 0], [Counter({280: 12, 320: 2}), 0], [Counter({170: 12, 280: 7}), 0]] For giggles, check the speed of your function using %%timeit %% timeit patterns = seed_patterns ( _widths , W ) 69.9 ms \u00b1 5.73 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each) 1.2.2 More permutations \u00b6 This is grand, but notice there are additional patterns that may be useful for our stock cutting problem. We were able to find: [Counter({280: 12, 320: 2}), 0], but notice how: [Counter({320: 9, 280: 4}), 0] is also a valid solution to fitting the two slit widths on stock. And in fact, the second solution may be one we need to produce our orders in as few stock rolls as possible. We'll come back to this question later on. 1.3 Comparison with old Alg \u00b6 %% timeit old_seed_patterns ( _widths , [ 200 , 200 , 200 ], W , len ( _widths ), verbiose = False ) 717 ms \u00b1 83.2 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) import itertools import numpy as np old_seed_patterns ( _widths , [ 200 , 200 , 200 ], W , len ( _widths ), goal = 10 , verbiose = False ) [array([Counter({170: 12, 280: 7}), 0], dtype=object), array([Counter({170: 16, 320: 4}), 0], dtype=object), array([Counter({280: 12, 320: 2}), 0], dtype=object), array([Counter({320: 9, 280: 4}), 0], dtype=object), array([Counter({170: 23}), 90], dtype=object), array([Counter({280: 14}), 80], dtype=object), array([Counter({320: 12}), 160], dtype=object)] def old_seed_patterns ( w , q , B , n , max_combinations = 3 , goal = 3 , verbiose = True ): ''' creates a number of optimal patterns for deckling Parameters ---------- w: list list of widths (int) q: list list of rolls for each width (int) B: int usuable width per mother roll n: list neck in for each width (int) max_combinations: int, default 3 maximum number of unique products (widths) to have on a mother roll goal: int, default 3 the desired number of recovered patterns from the knapsack problem for every unique grouping of unique widths at max_combinations verbiose: bool, default True turns on/off print statements during execution Returns ------- patterns: list of lists list of pattern, loss pairs. Pattern is a dictionary containing a width, count pair that describes the pattern on the mother roll. Loss is the percent material loss for the pattern. layout: list list of counts for every width on the mother roll. Layout is the best possible pattern in terms of minimizing mother rolls to create the order with a single pattern. ''' # layout = make_best_pattern(q, w, n, B, verbiose=verbiose) combos = [] for i in range ( 1 , max_combinations + 1 )[:: - 1 ]: combos += list ( itertools . combinations ( w , r = i )) if verbiose : print ( '' ) print ( \" {} possible max {} combinations\" . format ( len ( combos ), max_combinations )) patterns = [] for combo in combos : for combo in list ( itertools . permutations ( combo )): # due to the naive soln, combos of len 1 should be skipped. # knapsack/store_patterns will only find one solution (0?) if # the width is over half the length of the bin if len ( combo ) == 1 : sub_goal = 1 # arbitrary conditional elif sum ( combo ) > ( B - min ( combo )): sub_goal = 1 # if B / combo[0] < 2: # sub_goal = 1 # else: # sub_goal = goal else : sub_goal = goal # only provide knapsack with relevant variables s = [] for i in combo : s += ( int ( B / i ) * [ i ]) t = initt ( B , s ) knapsack ( s , B , len ( s ), t ) t = np . array ( t ) patterns += store_patterns ( t , s , B , goal = sub_goal ) for j in range ( 3 ): for i in patterns : for key in list ( i [ 0 ] . keys ()): loss = ( B - np . sum ( np . array ( list ( i [ 0 ] . keys ())) * np . array ( list ( i [ 0 ] . values ())))) - key if loss > 0 : i [ 0 ][ key ] += 1 i [ 1 ] = loss uni_list = [] for i in patterns : if i not in uni_list : uni_list . append ( i ) patterns = uni_list patterns = list ( np . array ( patterns )[ np . array ( patterns )[:, 1 ] >= 0 ]) # the naive patterns should be kept due to their usefullness # in order fulfilment regardless of loss # naive = init_layouts(B, w) # for i in naive: # i = [-j for j in i] # patterns.append([dict(zip(w,i)),0]) if verbiose : print ( \" {} unique patterns found\" . format ( len ( patterns ))) return patterns def store_patterns ( t , s , B , goal = 5 ): t = np . array ( t ) patterns = [] bit = 1 empty = False while ( len ( patterns ) < goal ): found = 0 for pair in np . argwhere ( t == t . flatten ()[ t . flatten () . argsort ()[ - bit ]]): N , W = pair sack = reconstruct ( N , W , t , s ) # terminate search if we are returning empty sets if sack == set (): empty = True break pattern = Counter ( np . array ( s )[ list ( sack )]) loss = B - np . sum ( np . array ( list ( pattern . keys ())) * np . array ( list ( pattern . values ()))) if loss >= 0 : patterns . append ([ pattern , loss ]) if len ( patterns ) >= goal : break found += 1 if found > 1 : break bit += 1 if empty : break return patterns","title":"Finding More Patterns"},{"location":"exercises/P2_Stock_Cutting/#stock-cutting-part-2-finding-good-but-not-best-patterns","text":"In this project notebook we'll be leveraging our solution to the knapsack problem to create viable patterns for stock cutting.","title":"Stock Cutting Part 2: Finding Good (But not Best) Patterns"},{"location":"exercises/P2_Stock_Cutting/#10-import-functions-and-libraries","text":"from collections import Counter def initt ( W , val ): return [[ None for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )] def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != None : return t [ n ][ w ] # now include the conditionals if wt [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( wt , val , w , n - 1 , t ), knapsack ( wt , val , w - wt [ n - 1 ], n - 1 , t ) + val [ n - 1 ]) return t [ n ][ w ] elif wt [ n - 1 ] > w : t [ n ][ w ] = knapsack ( wt , val , w , n - 1 , t ) return t [ n ][ w ] def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if t [ j + 1 ][ W ] not in t [ j ]: recon . add ( j ) W = W - wt [ j ] # move columns in table lookup if W < 0 : break else : continue return recon def test_small_bag (): # the problem parameters val = [ 60 , 50 , 70 , 30 ] wt = [ 5 , 3 , 4 , 2 ] W = 5 # the known solution max_val = 80 max_items = [ 50 , 30 ] t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert list ( pattern . keys ()) == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_val_weight_equality (): # the problem parameters val = wt = [ 2 , 2 , 2 , 2 , 5 , 5 , 5 , 5 ] W = 14 # the known solution max_val = 14 max_items = Counter ([ 5 , 5 , 2 , 2 ]) t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert pattern == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) test_small_bag () Optimal value found Optimal items found test_val_weight_equality () Optimal value found Optimal items found","title":"1.0: Import Functions and Libraries"},{"location":"exercises/P2_Stock_Cutting/#11-modifications-from-knapsack-to-cutting-stock","text":"You may have guessed this, but for all of our problems the wt list and val list will always be the same; they will be the list of widths scheduled to cut from stock. When we get our orders, we will need to adjust such that we are solving the appropriate problem with the knapsack function. To give an example, we might have 100 orders to fulfill with slitwidth 170. However we can max only fit 20 on a roll. In this situation, we don't want to include all 100 repeat widths in the knapsack problem, because we know we can't possibly fit that many. Instead, we want to only provide the maximum number of 170's we could possibly fit on a roll. This will make the algorithm more efficient.","title":"1.1 Modifications from knapsack to cutting stock"},{"location":"exercises/P2_Stock_Cutting/#111-can-we-simplify-the-knapsack-function","text":"wt = val = [ 170 , 280 , 320 ] W = 4000 t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) pattern Counter({170: 1, 280: 1, 320: 1})","title":"1.1.1 Can we simplify the knapsack function?"},{"location":"exercises/P2_Stock_Cutting/#exercise-1-replace-wt-and-val-in-knapsack-and-nonetype-in-initt","text":"Notice how in the above cell we set wt and val equal to our product widths. In the cell below, rewrite the knapsack function so that widths takes the place of both wt and val def initt ( W , val ): return [[ - 1 for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )] def knapsack ( widths , w , n , t ): # n, w will be the row, column of our table # solve the basecase. pass Do the same thing for the reconstruct function. And while we're at it, let's change N to n and W to w so that our variables are consistent across both functions def reconstruct ( n , w , t , widths ): pass and lets test our new functions widths = [ 170 , 280 , 320 ] W = 4000 t = initt ( W , widths ) best = knapsack ( widths , W , len ( widths ), t ) sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) pattern Counter({170: 1, 280: 1, 320: 1})","title":"\ud83c\udf92 Exercise 1: replace wt and val in knapsack and nonetype in initt"},{"location":"exercises/P2_Stock_Cutting/#112-how-many-slit-widths","text":"Does our answer to the knapsack problem above make sense? It does based on what we fed the function. However, in reality what we're looking for is the best pattern given a list of unique slit widths even if that requires repeating units of slit widths. So how do we modify the way we call the function? widths = [ 170 , 280 , 320 ] W = 4000 for w in widths : print ([ w ] * int ( W / w )) [170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170] [280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280] [320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320]","title":"1.1.2 How many slit widths?"},{"location":"exercises/P2_Stock_Cutting/#exercise-2-call-knapsack-with-a-modified-list-of-widths","text":"In the above, we created new lists that properly signify the maximum number of units we could fit into the stock width. It is this list of items that we wish to feed into our knapsack problem. Rewrite our call to the knapsack problem below Also include neckin when you send this to knapsack widths = [ 170 , 280 , 320 ] neckin = [ 5 , 6 , 7 ] W = 4000 # modify call to knapsack 3999 Counter({175: 3, 327: 8, 286: 3})","title":"\ud83c\udf92 Exercise 2: call knapsack with a modified list of widths"},{"location":"exercises/P2_Stock_Cutting/#exercise-3-report-the-loss","text":"As a last adjustment, we want to think of the loss from a pattern, not the total number of millimeters used. Calculate the loss widths = [ 170 , 280 , 320 ] neckin = [ 5 , 6 , 7 ] W = 4000 # modify call to knapsack 1 0.025 Counter({175: 3, 327: 8, 286: 3})","title":"\ud83c\udf92 Exercise 3: report the loss"},{"location":"exercises/P2_Stock_Cutting/#12-why-good-but-not-best","text":"The shortcoming of the knapsack problem is that while it is able to find the best possible configuration to maximize the value of a knapsack, it does not consider constraints around items we must include. That is, when we create a schedule for our stock cutter, it is necessary that we deliver all orders within a reasonable time. To over come this hurdle, we combine results from the knapsack problem (and any other pattern generative algorithm we would like to include) with a linear opimization task. We will cover the linear optimization task in a later notebook. Just know for now that we are still working on creating candidate patterns.","title":"1.2: Why good but not best?"},{"location":"exercises/P2_Stock_Cutting/#121-find-all-unique-combinations-of-slit-widths","text":"widths = [ 170 , 280 , 320 ] neckin = [ 5 , 6 , 7 ] W = 4000 # modify call to knapsack # this new list will represent what we actually send to the function knapsack new = [] for w in widths : new += [ w ] * int ( W / w ) widths = new t = initt ( W , widths ) best = knapsack ( widths , W , len ( widths ), t ) loss = W - best print ( loss ) percent = loss / W * 100 print ( percent ) sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) pattern 1 0.025 Counter({175: 3, 327: 8, 286: 3})","title":"1.2.1 Find all unique combinations of slit widths"},{"location":"exercises/P2_Stock_Cutting/#exercise-4-permutate-the-list-of-unique-widths","text":"from itertools import combinations _widths = [ 170 , 280 , 320 ] W = 4000 max_unique_layouts = 3 def seed_patterns ( _widths , W , max_unique_layouts = 3 ): patterns = [] for current_max in range ( 1 , max_unique_layouts + 1 ): pre_sacks = list ( combinations ( _widths , current_max )) for widths in pre_sacks : # your call to knapsack pass return patterns Call your function seed_patterns ( _widths , W ) [[Counter({170: 23}), 90], [Counter({280: 14}), 80], [Counter({320: 12}), 160], [Counter({170: 12, 280: 7}), 0], [Counter({170: 16, 320: 4}), 0], [Counter({280: 12, 320: 2}), 0], [Counter({170: 12, 280: 7}), 0]] For giggles, check the speed of your function using %%timeit %% timeit patterns = seed_patterns ( _widths , W ) 69.9 ms \u00b1 5.73 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)","title":"\ud83c\udf92 Exercise 4: permutate the list of unique widths"},{"location":"exercises/P2_Stock_Cutting/#122-more-permutations","text":"This is grand, but notice there are additional patterns that may be useful for our stock cutting problem. We were able to find: [Counter({280: 12, 320: 2}), 0], but notice how: [Counter({320: 9, 280: 4}), 0] is also a valid solution to fitting the two slit widths on stock. And in fact, the second solution may be one we need to produce our orders in as few stock rolls as possible. We'll come back to this question later on.","title":"1.2.2 More permutations"},{"location":"exercises/P2_Stock_Cutting/#13-comparison-with-old-alg","text":"%% timeit old_seed_patterns ( _widths , [ 200 , 200 , 200 ], W , len ( _widths ), verbiose = False ) 717 ms \u00b1 83.2 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) import itertools import numpy as np old_seed_patterns ( _widths , [ 200 , 200 , 200 ], W , len ( _widths ), goal = 10 , verbiose = False ) [array([Counter({170: 12, 280: 7}), 0], dtype=object), array([Counter({170: 16, 320: 4}), 0], dtype=object), array([Counter({280: 12, 320: 2}), 0], dtype=object), array([Counter({320: 9, 280: 4}), 0], dtype=object), array([Counter({170: 23}), 90], dtype=object), array([Counter({280: 14}), 80], dtype=object), array([Counter({320: 12}), 160], dtype=object)] def old_seed_patterns ( w , q , B , n , max_combinations = 3 , goal = 3 , verbiose = True ): ''' creates a number of optimal patterns for deckling Parameters ---------- w: list list of widths (int) q: list list of rolls for each width (int) B: int usuable width per mother roll n: list neck in for each width (int) max_combinations: int, default 3 maximum number of unique products (widths) to have on a mother roll goal: int, default 3 the desired number of recovered patterns from the knapsack problem for every unique grouping of unique widths at max_combinations verbiose: bool, default True turns on/off print statements during execution Returns ------- patterns: list of lists list of pattern, loss pairs. Pattern is a dictionary containing a width, count pair that describes the pattern on the mother roll. Loss is the percent material loss for the pattern. layout: list list of counts for every width on the mother roll. Layout is the best possible pattern in terms of minimizing mother rolls to create the order with a single pattern. ''' # layout = make_best_pattern(q, w, n, B, verbiose=verbiose) combos = [] for i in range ( 1 , max_combinations + 1 )[:: - 1 ]: combos += list ( itertools . combinations ( w , r = i )) if verbiose : print ( '' ) print ( \" {} possible max {} combinations\" . format ( len ( combos ), max_combinations )) patterns = [] for combo in combos : for combo in list ( itertools . permutations ( combo )): # due to the naive soln, combos of len 1 should be skipped. # knapsack/store_patterns will only find one solution (0?) if # the width is over half the length of the bin if len ( combo ) == 1 : sub_goal = 1 # arbitrary conditional elif sum ( combo ) > ( B - min ( combo )): sub_goal = 1 # if B / combo[0] < 2: # sub_goal = 1 # else: # sub_goal = goal else : sub_goal = goal # only provide knapsack with relevant variables s = [] for i in combo : s += ( int ( B / i ) * [ i ]) t = initt ( B , s ) knapsack ( s , B , len ( s ), t ) t = np . array ( t ) patterns += store_patterns ( t , s , B , goal = sub_goal ) for j in range ( 3 ): for i in patterns : for key in list ( i [ 0 ] . keys ()): loss = ( B - np . sum ( np . array ( list ( i [ 0 ] . keys ())) * np . array ( list ( i [ 0 ] . values ())))) - key if loss > 0 : i [ 0 ][ key ] += 1 i [ 1 ] = loss uni_list = [] for i in patterns : if i not in uni_list : uni_list . append ( i ) patterns = uni_list patterns = list ( np . array ( patterns )[ np . array ( patterns )[:, 1 ] >= 0 ]) # the naive patterns should be kept due to their usefullness # in order fulfilment regardless of loss # naive = init_layouts(B, w) # for i in naive: # i = [-j for j in i] # patterns.append([dict(zip(w,i)),0]) if verbiose : print ( \" {} unique patterns found\" . format ( len ( patterns ))) return patterns def store_patterns ( t , s , B , goal = 5 ): t = np . array ( t ) patterns = [] bit = 1 empty = False while ( len ( patterns ) < goal ): found = 0 for pair in np . argwhere ( t == t . flatten ()[ t . flatten () . argsort ()[ - bit ]]): N , W = pair sack = reconstruct ( N , W , t , s ) # terminate search if we are returning empty sets if sack == set (): empty = True break pattern = Counter ( np . array ( s )[ list ( sack )]) loss = B - np . sum ( np . array ( list ( pattern . keys ())) * np . array ( list ( pattern . values ()))) if loss >= 0 : patterns . append ([ pattern , loss ]) if len ( patterns ) >= goal : break found += 1 if found > 1 : break bit += 1 if empty : break return patterns","title":"1.3 Comparison with old Alg"},{"location":"exercises/P3_Stock_Cutting/","text":"Stock Cutting Part 3: The Column Generation Method \u00b6 In this project notebook we'll be combining our dynamic program from the knapsack problem with a strategy called the column generation method 1.0: Import Functions and Libraries \u00b6 from collections import Counter from itertools import combinations def seed_patterns ( _widths , W , max_unique_layouts = 3 ): patterns = [] for current_max in range ( 1 , max_unique_layouts + 1 ): pre_sacks = list ( combinations ( _widths , current_max )) for widths in pre_sacks : new = [] for w in widths : new += [ w ] * int ( W / w ) widths = new t = initt ( W , widths ) best = knapsack ( widths , widths , W , len ( widths ), t ) loss = W - best sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) patterns . append ([ pattern , loss ]) return patterns def initt ( W , val ): return [[ None for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )] def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != None : return t [ n ][ w ] # now include the conditionals if wt [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( wt , val , w , n - 1 , t ), knapsack ( wt , val , w - wt [ n - 1 ], n - 1 , t ) + val [ n - 1 ]) return t [ n ][ w ] elif wt [ n - 1 ] > w : t [ n ][ w ] = knapsack ( wt , val , w , n - 1 , t ) return t [ n ][ w ] def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if ( t [ j + 1 ][ W ] not in t [ j ]) and ( t [ j + 1 ][ W ] != 0 ): recon . add ( j ) W = W - wt [ j ] # move columns in table lookup if W < 0 : break else : continue return recon def test_small_bag (): # the problem parameters val = [ 60 , 50 , 70 , 30 ] wt = [ 5 , 3 , 4 , 2 ] W = 5 # the known solution max_val = 80 max_items = [ 50 , 30 ] t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert list ( pattern . keys ()) == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_val_weight_equality (): # the problem parameters val = wt = [ 2 , 2 , 2 , 2 , 5 , 5 , 5 , 5 ] W = 14 # the known solution max_val = 14 max_items = Counter ([ 5 , 5 , 2 , 2 ]) t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert pattern == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) test_small_bag () Optimal value found Optimal items found test_val_weight_equality () Optimal value found Optimal items found _widths = [ 170 , 280 , 320 ] W = 4000 max_unique_layouts = 3 seed_patterns ( _widths , W ) [[Counter({170: 23}), 90], [Counter({280: 14}), 80], [Counter({320: 12}), 160], [Counter({170: 12, 280: 7}), 0], [Counter({170: 16, 320: 4}), 0], [Counter({280: 12, 320: 2}), 0], [Counter({170: 12, 280: 7}), 0]] 2.0 The Restricted Master Problem (RMP) \u00b6 first we create our naieve solutions (restrict 1 layout per pattern) \ud83c\udf92 Exercise 1: Find the naive solutions using seed_patterns \u00b6 q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 # set the outcome equal to \"patterns\" patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) patterns [[Counter({4: 3}), 3], [Counter({6: 2}), 3], [Counter({7: 2}), 1]] # The LINEAR PROGRAM # A1 A2 A3 # represents a width # 3A1 0 0 X1 # 0 2A2 0 X2 # 0 0 2A3 X3 # MINIMIZE (X1 + X2 + X3) # A1 >= 80 # A2 >= 50 # A3 >= 1000 Then we perform the linear programming task. from scipy.optimize import linprog from math import ceil import numpy as np ### Setup LHS, RHS, and OBJ ### lhs_ineq = [] for pattern in patterns : # inset will be our full build of a given \"pattern\" inset = [] for width in widths : # try to access the slitwidth counts, otherwise # it means none of that slitwidth was included try : inset . append ( - pattern [ 0 ][ width ]) except : inset . append ( 0 ) # add inset to the set of equations (patterns) lhs_ineq . append ( inset ) lhs_ineq = np . array ( lhs_ineq ) . T . tolist () # rhs is the min orders we need for each slitwidth rhs_ineq = [ - i for i in q ] # min x1 + x2 + .... Xn obj = np . ones ( len ( lhs_ineq [ 0 ])) ### SOLVE THE LINPROG ### # linprog will determine the minimum number we need # of each pattern result = linprog ( c = obj , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) X = [ ceil ( i ) for i in result [ 'x' ]] print ( X ) print ( f \"total doffs: { sum ( X ) } \" ) [27, 25, 50] total doffs: 102 These values of X are the minimum doffs we need to fulfill our order quantities q given a set of patterns, patterns . The trick we next employee, is we determine how costly each width is to our solution. We do this by solving the dual variables of the linear program. The dual of a given linear program (LP) is another LP that is derived from the original (the primal) LP. Algorithmically this looks like the following: Each variable in the primal LP becomes a constraint in the dual LP Each constraint in the primal LP becomes a variable in the dual LP The objective direction is inversed \u2013 maximum in the primal becomes minimum in the dual and vice versa Notice below we switch the parameter fields for c and b_ub (the coefficients of the linear objective function and the linear constraint vector). And we take the negative transpose of our system of equations A_ub . dual_problem = linprog ( c = rhs_ineq , A_ub =- np . array ( lhs_ineq ) . T , b_ub = obj , method = \"revised simplex\" ) val = [ i for i in dual_problem [ 'x' ]] val [0.3333333333333333, 0.5, 0.5] Roughly, this outcome is similar to the number of doffs dedicated to each width, normalized by the quantity ordered for each width. (Note that this comparison is only approximately true but is meant to give a conceptual guide). [ i / j for i , j in zip ( X , q )] [0.3375, 0.5, 0.5] 3.0 The Column Generation Subproblem (CGSP) \u00b6 Ok. So what was that dual variable stuff all about? We are going to use the dual variable to update the value of each width. That's right, the behavior of each width in reference to the final doff quantities, X is used to bias the knapsack problem to give us a pattern that gives preferential treatment to the troublesome widths! wt = [ 4 , 6 , 7 ] W = 15 ### expand our list of widths and values # such that each unique width/value pair # can fill the whole mother roll new_wt = [] new_val = [] for w , v in zip ( wt , val ): new_wt += [ w ] * int ( W / w ) new_val += [ v ] * int ( W / w ) wt = new_wt val = new_val ### and then it's just business as usuall! t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) loss = W - best sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ wt [ i ] for i in list ( sack )]) print ( pattern ) value = Counter ([ val [ i ] for i in list ( sack )]) print ( value ) ### black magic - check if the value of the # knapsack is greater than 1 total = 0 for worth , multiple in value . items (): total += worth * multiple total > 1 Counter({4: 2, 6: 1}) Counter({0.3333333333333333: 2, 0.5: 1}) True \ud83c\udf92 Exercise 2: Append pattern to the growing list of patterns \u00b6 The last conditional above, total > 1 is our criteria for adding the new width to the growing host of patterns to then send to the RMP. If the total worth of the knapsack is greater than 1, this means our RMP will return a new solution with the added pattern that will result in overall fewer doffs. pattern Counter({4: 2, 6: 1}) # append to patterns patterns . append ([ pattern , 0 ]) lhs_ineq = [] for pattern in patterns : # inset will be our full build of a given \"pattern\" inset = [] for width in widths : # try to access the slitwidth counts, otherwise # it means none of that slitwidth was included try : inset . append ( - pattern [ 0 ][ width ]) except : inset . append ( 0 ) # add inset to the set of equations (patterns) lhs_ineq . append ( inset ) lhs_ineq = np . array ( lhs_ineq ) . T . tolist () # rhs is the min orders we need for each slitwidth rhs_ineq = [ - i for i in q ] # min x1 + x2 + .... Xn obj = np . ones ( len ( lhs_ineq [ 0 ])) # linprog will determine the minimum number we need # of each pattern result = linprog ( c = obj , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) X = [ ceil ( i ) for i in result [ 'x' ]] print ( X ) [0, 5, 50, 41] we see that the total number of doffs is reduced from 102 to 96! print ( f \"total doffs: { sum ( X ) } \" ) total doffs: 96 dual_problem = linprog ( c = rhs_ineq , A_ub =- np . array ( lhs_ineq ) . T , b_ub = obj , method = \"revised simplex\" ) val = [ i for i in dual_problem [ 'x' ]] val [0.25, 0.5, 0.5] wt = [ 4 , 6 , 7 ] W = 15 new_wt = [] new_val = [] for w , v in zip ( wt , val ): new_wt += [ w ] * int ( W / w ) new_val += [ v ] * int ( W / w ) wt = new_wt val = new_val t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) loss = W - best sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ wt [ i ] for i in list ( sack )]) print ( pattern ) value = Counter ([ val [ i ] for i in list ( sack )]) print ( value ) total = 0 for worth , multiple in value . items (): total += worth * multiple total > 1 Counter({4: 2, 6: 1}) Counter({0.25: 2, 0.5: 1}) False In this case, the knapsack problem does not produce a knapsack with a value greater than 1, and so we discontinue our CGSP! total 1.0 4.0 Functions \u00b6 Let's bundle our code into some functions from scipy.optimize import linprog from math import ceil import numpy as np def solveX ( patterns , widths , q ): lhs_ineq = [] for pattern in patterns : # inset will be our full build of a given \"pattern\" inset = [] for width in widths : # try to access the slitwidth counts, otherwise # it means none of that slitwidth was included try : inset . append ( - pattern [ 0 ][ width ]) except : inset . append ( 0 ) # add inset to the set of equations (patterns) lhs_ineq . append ( inset ) lhs_ineq = np . array ( lhs_ineq ) . T . tolist () # rhs is the min orders we need for each slitwidth rhs_ineq = [ - i for i in q ] # min x1 + x2 + .... Xn obj = np . ones ( len ( lhs_ineq [ 0 ])) # linprog will determine the minimum number we need # of each pattern result = linprog ( c = obj , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) X = [ ceil ( i ) for i in result [ 'x' ]] dual_problem = linprog ( c = rhs_ineq , A_ub =- np . array ( lhs_ineq ) . T , b_ub = obj , method = \"revised simplex\" ) val = [ i for i in dual_problem [ 'x' ]] return X , val def pack_knap ( wt , val , W ): new_wt = [] new_val = [] for w , v in zip ( wt , val ): new_wt += [ w ] * int ( W / w ) new_val += [ v ] * int ( W / w ) wt = new_wt val = new_val t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) loss = W - best sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ wt [ i ] for i in list ( sack )]) value = Counter ([ val [ i ] for i in list ( sack )]) total = 0 # the number we need to surpass 1 for worth , multiple in value . items (): total += worth * multiple return pattern , total Starting over with the former example... We seed our patterns with the naive solutions q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) patterns [[Counter({4: 3}), 3], [Counter({6: 2}), 3], [Counter({7: 2}), 1]] We solve the RMP X , val = solveX ( patterns , widths , q ) print ( sum ( X )) print ( X , val ) 102 [27, 25, 50] [0.3333333333333333, 0.5, 0.5] We solve the CGSP pattern , total = pack_knap ( w , val , W ) print ( pattern , total ) print ( total > 1 ) Counter({4: 2, 6: 1}) 1.1666666666666665 True Since the value is greater than 1 we add the pattern to our linprog and solve the RMP again patterns . append ([ pattern , 0 ]) X , val = solveX ( patterns , widths , q ) print ( sum ( X )) print ( X , val ) pattern , total = pack_knap ( w , val , W ) print ( pattern , total ) print ( total > 1 ) 96 [0, 5, 50, 41] [0.25, 0.5, 0.5] Counter({4: 2, 6: 1}) 1.0 False We exit when we can no longer find a pattern that would improve the RMP 5.0 All Together Now \u00b6 \ud83c\udf92 Exercise 3: Wrap Part 4.0 into a while loop to automate the combination of the RMP and CGSP \u00b6 q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) while True : pass print () print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) total doffs: 96 5, Counter({6: 2}) 50, Counter({7: 2}) 41, Counter({4: 2, 6: 1})","title":"The Column Generation Method"},{"location":"exercises/P3_Stock_Cutting/#stock-cutting-part-3-the-column-generation-method","text":"In this project notebook we'll be combining our dynamic program from the knapsack problem with a strategy called the column generation method","title":"Stock Cutting Part 3: The Column Generation Method"},{"location":"exercises/P3_Stock_Cutting/#10-import-functions-and-libraries","text":"from collections import Counter from itertools import combinations def seed_patterns ( _widths , W , max_unique_layouts = 3 ): patterns = [] for current_max in range ( 1 , max_unique_layouts + 1 ): pre_sacks = list ( combinations ( _widths , current_max )) for widths in pre_sacks : new = [] for w in widths : new += [ w ] * int ( W / w ) widths = new t = initt ( W , widths ) best = knapsack ( widths , widths , W , len ( widths ), t ) loss = W - best sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) patterns . append ([ pattern , loss ]) return patterns def initt ( W , val ): return [[ None for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )] def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != None : return t [ n ][ w ] # now include the conditionals if wt [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( wt , val , w , n - 1 , t ), knapsack ( wt , val , w - wt [ n - 1 ], n - 1 , t ) + val [ n - 1 ]) return t [ n ][ w ] elif wt [ n - 1 ] > w : t [ n ][ w ] = knapsack ( wt , val , w , n - 1 , t ) return t [ n ][ w ] def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if ( t [ j + 1 ][ W ] not in t [ j ]) and ( t [ j + 1 ][ W ] != 0 ): recon . add ( j ) W = W - wt [ j ] # move columns in table lookup if W < 0 : break else : continue return recon def test_small_bag (): # the problem parameters val = [ 60 , 50 , 70 , 30 ] wt = [ 5 , 3 , 4 , 2 ] W = 5 # the known solution max_val = 80 max_items = [ 50 , 30 ] t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert list ( pattern . keys ()) == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_val_weight_equality (): # the problem parameters val = wt = [ 2 , 2 , 2 , 2 , 5 , 5 , 5 , 5 ] W = 14 # the known solution max_val = 14 max_items = Counter ([ 5 , 5 , 2 , 2 ]) t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert pattern == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) test_small_bag () Optimal value found Optimal items found test_val_weight_equality () Optimal value found Optimal items found _widths = [ 170 , 280 , 320 ] W = 4000 max_unique_layouts = 3 seed_patterns ( _widths , W ) [[Counter({170: 23}), 90], [Counter({280: 14}), 80], [Counter({320: 12}), 160], [Counter({170: 12, 280: 7}), 0], [Counter({170: 16, 320: 4}), 0], [Counter({280: 12, 320: 2}), 0], [Counter({170: 12, 280: 7}), 0]]","title":"1.0: Import Functions and Libraries"},{"location":"exercises/P3_Stock_Cutting/#20-the-restricted-master-problem-rmp","text":"first we create our naieve solutions (restrict 1 layout per pattern)","title":"2.0 The Restricted Master Problem (RMP)"},{"location":"exercises/P3_Stock_Cutting/#exercise-1-find-the-naive-solutions-using-seed_patterns","text":"q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 # set the outcome equal to \"patterns\" patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) patterns [[Counter({4: 3}), 3], [Counter({6: 2}), 3], [Counter({7: 2}), 1]] # The LINEAR PROGRAM # A1 A2 A3 # represents a width # 3A1 0 0 X1 # 0 2A2 0 X2 # 0 0 2A3 X3 # MINIMIZE (X1 + X2 + X3) # A1 >= 80 # A2 >= 50 # A3 >= 1000 Then we perform the linear programming task. from scipy.optimize import linprog from math import ceil import numpy as np ### Setup LHS, RHS, and OBJ ### lhs_ineq = [] for pattern in patterns : # inset will be our full build of a given \"pattern\" inset = [] for width in widths : # try to access the slitwidth counts, otherwise # it means none of that slitwidth was included try : inset . append ( - pattern [ 0 ][ width ]) except : inset . append ( 0 ) # add inset to the set of equations (patterns) lhs_ineq . append ( inset ) lhs_ineq = np . array ( lhs_ineq ) . T . tolist () # rhs is the min orders we need for each slitwidth rhs_ineq = [ - i for i in q ] # min x1 + x2 + .... Xn obj = np . ones ( len ( lhs_ineq [ 0 ])) ### SOLVE THE LINPROG ### # linprog will determine the minimum number we need # of each pattern result = linprog ( c = obj , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) X = [ ceil ( i ) for i in result [ 'x' ]] print ( X ) print ( f \"total doffs: { sum ( X ) } \" ) [27, 25, 50] total doffs: 102 These values of X are the minimum doffs we need to fulfill our order quantities q given a set of patterns, patterns . The trick we next employee, is we determine how costly each width is to our solution. We do this by solving the dual variables of the linear program. The dual of a given linear program (LP) is another LP that is derived from the original (the primal) LP. Algorithmically this looks like the following: Each variable in the primal LP becomes a constraint in the dual LP Each constraint in the primal LP becomes a variable in the dual LP The objective direction is inversed \u2013 maximum in the primal becomes minimum in the dual and vice versa Notice below we switch the parameter fields for c and b_ub (the coefficients of the linear objective function and the linear constraint vector). And we take the negative transpose of our system of equations A_ub . dual_problem = linprog ( c = rhs_ineq , A_ub =- np . array ( lhs_ineq ) . T , b_ub = obj , method = \"revised simplex\" ) val = [ i for i in dual_problem [ 'x' ]] val [0.3333333333333333, 0.5, 0.5] Roughly, this outcome is similar to the number of doffs dedicated to each width, normalized by the quantity ordered for each width. (Note that this comparison is only approximately true but is meant to give a conceptual guide). [ i / j for i , j in zip ( X , q )] [0.3375, 0.5, 0.5]","title":"\ud83c\udf92 Exercise 1: Find the naive solutions using seed_patterns"},{"location":"exercises/P3_Stock_Cutting/#30-the-column-generation-subproblem-cgsp","text":"Ok. So what was that dual variable stuff all about? We are going to use the dual variable to update the value of each width. That's right, the behavior of each width in reference to the final doff quantities, X is used to bias the knapsack problem to give us a pattern that gives preferential treatment to the troublesome widths! wt = [ 4 , 6 , 7 ] W = 15 ### expand our list of widths and values # such that each unique width/value pair # can fill the whole mother roll new_wt = [] new_val = [] for w , v in zip ( wt , val ): new_wt += [ w ] * int ( W / w ) new_val += [ v ] * int ( W / w ) wt = new_wt val = new_val ### and then it's just business as usuall! t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) loss = W - best sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ wt [ i ] for i in list ( sack )]) print ( pattern ) value = Counter ([ val [ i ] for i in list ( sack )]) print ( value ) ### black magic - check if the value of the # knapsack is greater than 1 total = 0 for worth , multiple in value . items (): total += worth * multiple total > 1 Counter({4: 2, 6: 1}) Counter({0.3333333333333333: 2, 0.5: 1}) True","title":"3.0 The Column Generation Subproblem (CGSP)"},{"location":"exercises/P3_Stock_Cutting/#exercise-2-append-pattern-to-the-growing-list-of-patterns","text":"The last conditional above, total > 1 is our criteria for adding the new width to the growing host of patterns to then send to the RMP. If the total worth of the knapsack is greater than 1, this means our RMP will return a new solution with the added pattern that will result in overall fewer doffs. pattern Counter({4: 2, 6: 1}) # append to patterns patterns . append ([ pattern , 0 ]) lhs_ineq = [] for pattern in patterns : # inset will be our full build of a given \"pattern\" inset = [] for width in widths : # try to access the slitwidth counts, otherwise # it means none of that slitwidth was included try : inset . append ( - pattern [ 0 ][ width ]) except : inset . append ( 0 ) # add inset to the set of equations (patterns) lhs_ineq . append ( inset ) lhs_ineq = np . array ( lhs_ineq ) . T . tolist () # rhs is the min orders we need for each slitwidth rhs_ineq = [ - i for i in q ] # min x1 + x2 + .... Xn obj = np . ones ( len ( lhs_ineq [ 0 ])) # linprog will determine the minimum number we need # of each pattern result = linprog ( c = obj , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) X = [ ceil ( i ) for i in result [ 'x' ]] print ( X ) [0, 5, 50, 41] we see that the total number of doffs is reduced from 102 to 96! print ( f \"total doffs: { sum ( X ) } \" ) total doffs: 96 dual_problem = linprog ( c = rhs_ineq , A_ub =- np . array ( lhs_ineq ) . T , b_ub = obj , method = \"revised simplex\" ) val = [ i for i in dual_problem [ 'x' ]] val [0.25, 0.5, 0.5] wt = [ 4 , 6 , 7 ] W = 15 new_wt = [] new_val = [] for w , v in zip ( wt , val ): new_wt += [ w ] * int ( W / w ) new_val += [ v ] * int ( W / w ) wt = new_wt val = new_val t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) loss = W - best sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ wt [ i ] for i in list ( sack )]) print ( pattern ) value = Counter ([ val [ i ] for i in list ( sack )]) print ( value ) total = 0 for worth , multiple in value . items (): total += worth * multiple total > 1 Counter({4: 2, 6: 1}) Counter({0.25: 2, 0.5: 1}) False In this case, the knapsack problem does not produce a knapsack with a value greater than 1, and so we discontinue our CGSP! total 1.0","title":"\ud83c\udf92 Exercise 2: Append pattern to the growing list of patterns"},{"location":"exercises/P3_Stock_Cutting/#40-functions","text":"Let's bundle our code into some functions from scipy.optimize import linprog from math import ceil import numpy as np def solveX ( patterns , widths , q ): lhs_ineq = [] for pattern in patterns : # inset will be our full build of a given \"pattern\" inset = [] for width in widths : # try to access the slitwidth counts, otherwise # it means none of that slitwidth was included try : inset . append ( - pattern [ 0 ][ width ]) except : inset . append ( 0 ) # add inset to the set of equations (patterns) lhs_ineq . append ( inset ) lhs_ineq = np . array ( lhs_ineq ) . T . tolist () # rhs is the min orders we need for each slitwidth rhs_ineq = [ - i for i in q ] # min x1 + x2 + .... Xn obj = np . ones ( len ( lhs_ineq [ 0 ])) # linprog will determine the minimum number we need # of each pattern result = linprog ( c = obj , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) X = [ ceil ( i ) for i in result [ 'x' ]] dual_problem = linprog ( c = rhs_ineq , A_ub =- np . array ( lhs_ineq ) . T , b_ub = obj , method = \"revised simplex\" ) val = [ i for i in dual_problem [ 'x' ]] return X , val def pack_knap ( wt , val , W ): new_wt = [] new_val = [] for w , v in zip ( wt , val ): new_wt += [ w ] * int ( W / w ) new_val += [ v ] * int ( W / w ) wt = new_wt val = new_val t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) loss = W - best sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ wt [ i ] for i in list ( sack )]) value = Counter ([ val [ i ] for i in list ( sack )]) total = 0 # the number we need to surpass 1 for worth , multiple in value . items (): total += worth * multiple return pattern , total Starting over with the former example... We seed our patterns with the naive solutions q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) patterns [[Counter({4: 3}), 3], [Counter({6: 2}), 3], [Counter({7: 2}), 1]] We solve the RMP X , val = solveX ( patterns , widths , q ) print ( sum ( X )) print ( X , val ) 102 [27, 25, 50] [0.3333333333333333, 0.5, 0.5] We solve the CGSP pattern , total = pack_knap ( w , val , W ) print ( pattern , total ) print ( total > 1 ) Counter({4: 2, 6: 1}) 1.1666666666666665 True Since the value is greater than 1 we add the pattern to our linprog and solve the RMP again patterns . append ([ pattern , 0 ]) X , val = solveX ( patterns , widths , q ) print ( sum ( X )) print ( X , val ) pattern , total = pack_knap ( w , val , W ) print ( pattern , total ) print ( total > 1 ) 96 [0, 5, 50, 41] [0.25, 0.5, 0.5] Counter({4: 2, 6: 1}) 1.0 False We exit when we can no longer find a pattern that would improve the RMP","title":"4.0 Functions"},{"location":"exercises/P3_Stock_Cutting/#50-all-together-now","text":"","title":"5.0 All Together Now"},{"location":"exercises/P3_Stock_Cutting/#exercise-3-wrap-part-40-into-a-while-loop-to-automate-the-combination-of-the-rmp-and-cgsp","text":"q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) while True : pass print () print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) total doffs: 96 5, Counter({6: 2}) 50, Counter({7: 2}) 41, Counter({4: 2, 6: 1})","title":"\ud83c\udf92 Exercise 3: Wrap Part 4.0 into a while loop to automate the combination of the RMP and CGSP"},{"location":"solutions/SOLN_P1_Stock_Cutting/","text":"Stock Cutting Part 1: Finding Good Patterns \u00b6 In this project notebook we'll be laying the foundations of stock cutting. We'll begin by discussing the common dynamic programming problem: the knapsack problem Supporting Material Video (15 mins) 1.0: What is the knapsack Problem? \u00b6 From Wikipedia : The knapsack problem is a problem in combinatorial optimization: Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. It derives its name from the problem faced by someone who is constrained by a fixed-size knapsack and must fill it with the most valuable items. The problem often arises in resource allocation where the decision makers have to choose from a set of non-divisible projects or tasks under a fixed budget or time constraint, respectively. 1.2: Simple Knapsack \u00b6 Say we have the following items we want to fit into a bag. Our total weight limit is 8 lbs. The items are worth 1, 2, 5, and 6 dollars apiece and weigh 2, 3, 4, and 5 lbs. val = [1, 2, 5, 6] wt = [2, 3, 4, 5] W = 8 We may be able to solve in our own minds that the maximum value here is items of value 2 and 6 for a total value of 8 dollars and total weight of 8 lbs. How do we solve this algorithmically? val = [ 1 , 2 , 5 , 6 ] wt = [ 2 , 3 , 4 , 5 ] W = 8 the table we would fill out looks like the following Value Weight 0 1 2 3 4 5 6 7 8 None None 0 0 0 0 0 0 0 0 0 1 2 0 0 1 1 1 1 1 1 1 2 3 0 0 1 2 2 3 3 3 3 5 4 0 0 1 2 5 5 6 6 7 6 5 0 0 1 2 5 6 6 7 8 The column headers (after Value and Weight) indicate the maximum weight allowable under that column. Every row indicates what items are allowable i.e. on row 2 we only consider item 1, on row 3 we consider items 1 and 2, and so forth. Let's walk through a few cells. In the first two columns, we can't include any items under this weight restriction, hence all cell values are 0. In column 2, row 2, we are able to fit item 1 under this weight constraint, so the value of our knapsack increases to 1 In the remaining cells of row 2, our value is persistant at a total of 1, since we are only considering the first item in this row Moving onto the second row, things get interesting at row 3, column 3 if n is our current item, and w is the current weight (i.e. n is the row and w is the column) then we want to fill in the current cell t[n,w] with the maximum value: t[n-1,w] or t[n-1, W-wt[n]] + val[n] Let's make sense of the max statement in 4.B. We know that at the current cell, we can always default to the value of the cell above ( t[n-1,w] ). The trick comes in the second part of the max statement. We look at the total value if we were to add the current item ( val[n] ), to the value back in the table in the previous row [n-1] where the total weight is equal to the current weight under consideration minus the weight of the current item ( W-wt[n] ) Now we'll go into our second point. Take a look at row 4, column 3 (directly below the cell we were considering before) in this case, the weight of the current item (4 lbs) is more than the maximum allowable weight (3 lbs) and so in this case we default to the value in the cell above ( t[n-1, w] ) algorithmically this looks like the following: if wt[n] <= W: return max(t[n-1,w], t[n-1, W-wt[n]] + val[n]) elif wt[n] > W: return t[n-1, w] 1.2.1 Use recursion to find the optimum value of the knapsack \u00b6 The insight we require is that in the above code block, we want to run this conditional on the bottom right corner of the table, where we have allowed the maximum possible weight in the bag and included all items for consideration. But in order to ask this we need to know the values in the preceding cells of the table! This is where recurssion comes in handy. Our recursive algorithm will return t[n][w] for the given parameters of wt (weights), val (values), W (max allowable weight), and, well t , the table itself. \ud83c\udf92 Exercise 1: Create the empty table as a list of lists \u00b6 Before writing the knapsack function, we will need to initialize our empty table: # We initialize the table. note that I am adding a 0th row and a 0th column # at the top and left of the table respectively. The table # needs to be len(val) + 1 rows and W + 1 columns t = [[ None for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )] t [[None, None, None, None, None, None, None, None, None], [None, None, None, None, None, None, None, None, None], [None, None, None, None, None, None, None, None, None], [None, None, None, None, None, None, None, None, None], [None, None, None, None, None, None, None, None, None]] after you've propery coded out the table wrap this into a function initt # we'll wrap the above into a function for ease of use def initt ( W , val ): return [[ None for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )] \ud83c\udf92 Exercise 2: Complete the function knapsack using recursion without memoization \u00b6 Note that we need to think about how our indexing will work between the table, t , and our list representations of our items, wt and val . index 0 in our table means no items and no weight whereas in our list index 0 reprents item 1 so in the following knapsack function we need to shift all our indexing's of wt and val backwards by 1 (this is the difference between the code in the function and the mathematical representation in Section 1.2) def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 # now include the conditionals if wt [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( wt , val , w , n - 1 , t ), knapsack ( wt , val , w - wt [ n - 1 ], n - 1 , t ) + val [ n - 1 ]) return t [ n ][ w ] elif wt [ n - 1 ] > w : t [ n ][ w ] = knapsack ( wt , val , w , n - 1 , t ) return t [ n ][ w ] knapsack ( wt , val , W , len ( val ), t ) 8 If we look at the output of our table, we will see that it matches the one we described in Section 1.2 Value Weight 0 1 2 3 4 5 6 7 8 None None 0 0 0 0 0 0 0 0 0 1 2 0 0 1 1 1 1 1 1 1 2 3 0 0 1 2 2 3 3 3 3 5 4 0 0 1 2 5 5 6 6 7 6 5 0 0 1 2 5 6 6 7 8 it turns out that we did not have to visit every cell in the table however, to arrive at the optimal value of our knapsack: t [[None, None, None, None, None, None, None, None, None], [None, 0, None, 1, 1, 1, None, None, 1], [None, None, None, 2, 2, None, None, None, 3], [None, None, None, 2, None, None, None, None, 7], [None, None, None, None, None, None, None, None, 8]] 1.2.2 Enrichment: use memoization to speed up the solution \u00b6 Memoization is a techniqued used along with recursion to create dynamic programms . We let our recursive algorithm know when we've already visited a subproblem by passing along a table (which in this case, we already have) \ud83c\udf92 Exercise 3: Check if we have already visited a location in the table \u00b6 def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != None : return t [ n ][ w ] # now include the conditionals if wt [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( wt , val , w , n - 1 , t ), knapsack ( wt , val , w - wt [ n - 1 ], n - 1 , t ) + val [ n - 1 ]) return t [ n ][ w ] elif wt [ n - 1 ] > w : t [ n ][ w ] = knapsack ( wt , val , w , n - 1 , t ) return t [ n ][ w ] 1.2.3 Reconstruct what items were added to the knapsack by reading the table \u00b6 The next part of the puzzle is to determine what items were added to the knapsack to achieve this optimal result! We can infer this from the table. Take a look at the table again, the algorithm we will envoke is that if the current cell's value does not appear in the previous row, it is because added that row's item! To see what else is in that hypothetical knapsack, we simply move up a row and left the number of columns equal to the last item we added, and repeat the process \ud83c\udf92 Exercise 4: Complete the pseudo code below to create a set that includes all the items in the knapsack \u00b6 recon = set () column = W # we will iterate through the rows of the table from bottom to top for row in range ( len ( val ))[:: - 1 ]: # we know that if the current cell value is not anywhere in the # previous row, it is because we added that item to the knapsack # remember that the table indexing is shifted forward compared to # the list indexes if t [ row + 1 ][ column ] not in t [ row ]: recon . add ( row ) # after we add the item, we need to adjust the weight the appropriate # number of steps column -= wt [ row ] # we will stop after we reach the 0th (no weight) column if column < 0 : break else : continue recon set() \ud83c\udf92 Exercise 5: Wrap this in a function called reconstruct \u00b6 we see that the output of the reconstruction are the second and fourth items (index starts at 0), which is what we expected! Let's package this into a function def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if t [ j + 1 ][ W ] not in t [ j ]: recon . add ( j ) W = W - wt [ j ] # move columns in table lookup if W < 0 : break else : continue return recon Now, to translate these indices to actual items we're going to use a function called Counter Dict subclass for counting hashable items. Sometimes called a bag or multiset. Elements are stored as dictionary keys and their counts are stored as dictionary values. We'll use Counter along with Numpy to take our indices/val list and count the number of times an item was used in the solution import numpy as np from collections import Counter sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ( np . array ( val )[ list ( sack )]) pattern sack {1, 3} 1.3 Unit Tests \u00b6 It is always good practice to test as we go. Let's make sure our algorithm works on some known subproblems def test_small_bag (): # the problem parameters val = [ 60 , 50 , 70 , 30 ] wt = [ 5 , 3 , 4 , 2 ] W = 5 # the known solution max_val = 80 max_items = [ 50 , 30 ] t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ( np . array ( val )[ list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert list ( pattern . keys ()) == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) test_small_bag () --------------------------------------------------------------------------- TypeError Traceback (most recent call last) c:\\Users\\Malek MFG\\pay\\deka\\notebooks\\solutions\\SOLN_P1_Stock_Cutting.ipynb Cell 31' in <cell line: 1>() ----> <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000030?line=0'>1</a> test_small_bag() c:\\Users\\Malek MFG\\pay\\deka\\notebooks\\solutions\\SOLN_P1_Stock_Cutting.ipynb Cell 30' in test_small_bag() <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000029?line=7'>8</a> max_val = 80 <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000029?line=8'>9</a> max_items = [50, 30] ---> <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000029?line=10'>11</a> t = initt(W, val) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000029?line=11'>12</a> best = knapsack(wt, val, W, len(val), t) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000029?line=12'>13</a> sack = reconstruct(len(val), W, t, wt) c:\\Users\\Malek MFG\\pay\\deka\\notebooks\\solutions\\SOLN_P1_Stock_Cutting.ipynb Cell 35' in initt(B, lens) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=55'>56</a> \"\"\" <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=56'>57</a> t, the returned table, will be a list of lists, but if transformed to <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=57'>58</a> an array it takes the shape of the number of products + 1 (len(s) + 1) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=58'>59</a> by the usable width + 1 (B + 1) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=59'>60</a> \"\"\" <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=60'>61</a> # We initialize the matrix with -1 at first. ---> <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=61'>62</a> return [[-1 for i in range(B + 1)] for j in range(lens + 1)] TypeError: can only concatenate list (not \"int\") to list def test_val_weight_equality (): # the problem parameters val = wt = [ 2 , 2 , 2 , 2 , 5 , 5 , 5 , 5 ] W = 14 # the known solution max_val = 14 max_items = Counter ([ 5 , 5 , 2 , 2 ]) t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ( np . array ( val )[ list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert pattern == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) test_val_weight_equality () --------------------------------------------------------------------------- TypeError Traceback (most recent call last) c:\\Users\\Malek MFG\\pay\\deka\\notebooks\\solutions\\SOLN_P1_Stock_Cutting.ipynb Cell 33' in <cell line: 1>() ----> <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000032?line=0'>1</a> test_val_weight_equality() c:\\Users\\Malek MFG\\pay\\deka\\notebooks\\solutions\\SOLN_P1_Stock_Cutting.ipynb Cell 32' in test_val_weight_equality() <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000031?line=6'>7</a> max_val = 14 <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000031?line=7'>8</a> max_items = Counter([5, 5, 2, 2]) ---> <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000031?line=9'>10</a> t = initt(W, val) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000031?line=10'>11</a> best = knapsack(wt, val, W, len(val), t) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000031?line=11'>12</a> sack = reconstruct(len(val), W, t, wt) c:\\Users\\Malek MFG\\pay\\deka\\notebooks\\solutions\\SOLN_P1_Stock_Cutting.ipynb Cell 35' in initt(B, lens) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=55'>56</a> \"\"\" <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=56'>57</a> t, the returned table, will be a list of lists, but if transformed to <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=57'>58</a> an array it takes the shape of the number of products + 1 (len(s) + 1) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=58'>59</a> by the usable width + 1 (B + 1) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=59'>60</a> \"\"\" <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=60'>61</a> # We initialize the matrix with -1 at first. ---> <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=61'>62</a> return [[-1 for i in range(B + 1)] for j in range(lens + 1)] TypeError: can only concatenate list (not \"int\") to list 1.4 Save our functions \u00b6 import numpy as np from collections import Counter def knapsack ( wt , val , W , n , t ): \"\"\" in our particular case, the wt and val of the item are the same wt/val is 's' and is the items sorted by length, increasing wt: list the ordered weights (lengths of the rolls) val: list the ordered values (lengths of the rolls) W: int the weight of the current knapsack (the used length of the mother roll) n: int the number of items in the mother roll t: list of list the knapsack table \"\"\" # base conditions if n == 0 or W == 0 : # the first row and first column of the table is filled with 0s return 0 if t [ n ][ W ] != - 1 : # already solved at [n][W] return t [ n ][ W ] # choice diagram code if wt [ n - 1 ] <= W : # if the previous item under consideration is less than the current # weight left in the mother roll # we can now do 1 of 2 things add the new item in (and take the val # of the bag at the previous lvl w/o the item) (the answer to the left # in the table) plus the new wt/val or we use the best answer from one # fewer items at this weight lvl (the answer above the current cell in # the table) # t[n,w] = max{t[n-1,w], t[n-1, w-w[n-1]] + val[n-1]} # note that in the following wt and val are indexed starting at 0 # but t/knapsack is indexed starting at 1 (index 0 in the table is all # 0's) t [ n ][ W ] = max ( val [ n - 1 ] + knapsack ( wt , val , W - wt [ n - 1 ], n - 1 , t ), knapsack ( wt , val , W , n - 1 , t )) return t [ n ][ W ] elif wt [ n - 1 ] > W : # if wt/val of the current item under consideration is more than the # weight left in the bag, we've already found the best solution for # this number of items t [ n ][ W ] = knapsack ( wt , val , W , n - 1 , t ) return t [ n ][ W ] def initt ( B , lens ): \"\"\" t, the returned table, will be a list of lists, but if transformed to an array it takes the shape of the number of products + 1 (len(s) + 1) by the usable width + 1 (B + 1) \"\"\" # We initialize the matrix with -1 at first. return [[ - 1 for i in range ( B + 1 )] for j in range ( lens + 1 )] def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if t [ j + 1 , W ] not in t [ j ,:]: recon . add ( j ) W = W - wt [ j ] # move columns in table lookup if W < 0 : break else : continue return recon 1.5 Lab \u00b6 In the deka repository add our functions to enginge.py and our unit_tests to test_engine.py make sure you can run the tests via the Makefile","title":"The Knapsack Problem"},{"location":"solutions/SOLN_P1_Stock_Cutting/#stock-cutting-part-1-finding-good-patterns","text":"In this project notebook we'll be laying the foundations of stock cutting. We'll begin by discussing the common dynamic programming problem: the knapsack problem Supporting Material Video (15 mins)","title":"Stock Cutting Part 1: Finding Good Patterns"},{"location":"solutions/SOLN_P1_Stock_Cutting/#10-what-is-the-knapsack-problem","text":"From Wikipedia : The knapsack problem is a problem in combinatorial optimization: Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. It derives its name from the problem faced by someone who is constrained by a fixed-size knapsack and must fill it with the most valuable items. The problem often arises in resource allocation where the decision makers have to choose from a set of non-divisible projects or tasks under a fixed budget or time constraint, respectively.","title":"1.0: What is the knapsack Problem?"},{"location":"solutions/SOLN_P1_Stock_Cutting/#12-simple-knapsack","text":"Say we have the following items we want to fit into a bag. Our total weight limit is 8 lbs. The items are worth 1, 2, 5, and 6 dollars apiece and weigh 2, 3, 4, and 5 lbs. val = [1, 2, 5, 6] wt = [2, 3, 4, 5] W = 8 We may be able to solve in our own minds that the maximum value here is items of value 2 and 6 for a total value of 8 dollars and total weight of 8 lbs. How do we solve this algorithmically? val = [ 1 , 2 , 5 , 6 ] wt = [ 2 , 3 , 4 , 5 ] W = 8 the table we would fill out looks like the following Value Weight 0 1 2 3 4 5 6 7 8 None None 0 0 0 0 0 0 0 0 0 1 2 0 0 1 1 1 1 1 1 1 2 3 0 0 1 2 2 3 3 3 3 5 4 0 0 1 2 5 5 6 6 7 6 5 0 0 1 2 5 6 6 7 8 The column headers (after Value and Weight) indicate the maximum weight allowable under that column. Every row indicates what items are allowable i.e. on row 2 we only consider item 1, on row 3 we consider items 1 and 2, and so forth. Let's walk through a few cells. In the first two columns, we can't include any items under this weight restriction, hence all cell values are 0. In column 2, row 2, we are able to fit item 1 under this weight constraint, so the value of our knapsack increases to 1 In the remaining cells of row 2, our value is persistant at a total of 1, since we are only considering the first item in this row Moving onto the second row, things get interesting at row 3, column 3 if n is our current item, and w is the current weight (i.e. n is the row and w is the column) then we want to fill in the current cell t[n,w] with the maximum value: t[n-1,w] or t[n-1, W-wt[n]] + val[n] Let's make sense of the max statement in 4.B. We know that at the current cell, we can always default to the value of the cell above ( t[n-1,w] ). The trick comes in the second part of the max statement. We look at the total value if we were to add the current item ( val[n] ), to the value back in the table in the previous row [n-1] where the total weight is equal to the current weight under consideration minus the weight of the current item ( W-wt[n] ) Now we'll go into our second point. Take a look at row 4, column 3 (directly below the cell we were considering before) in this case, the weight of the current item (4 lbs) is more than the maximum allowable weight (3 lbs) and so in this case we default to the value in the cell above ( t[n-1, w] ) algorithmically this looks like the following: if wt[n] <= W: return max(t[n-1,w], t[n-1, W-wt[n]] + val[n]) elif wt[n] > W: return t[n-1, w]","title":"1.2: Simple Knapsack"},{"location":"solutions/SOLN_P1_Stock_Cutting/#121-use-recursion-to-find-the-optimum-value-of-the-knapsack","text":"The insight we require is that in the above code block, we want to run this conditional on the bottom right corner of the table, where we have allowed the maximum possible weight in the bag and included all items for consideration. But in order to ask this we need to know the values in the preceding cells of the table! This is where recurssion comes in handy. Our recursive algorithm will return t[n][w] for the given parameters of wt (weights), val (values), W (max allowable weight), and, well t , the table itself.","title":"1.2.1 Use recursion to find the optimum value of the knapsack"},{"location":"solutions/SOLN_P1_Stock_Cutting/#exercise-1-create-the-empty-table-as-a-list-of-lists","text":"Before writing the knapsack function, we will need to initialize our empty table: # We initialize the table. note that I am adding a 0th row and a 0th column # at the top and left of the table respectively. The table # needs to be len(val) + 1 rows and W + 1 columns t = [[ None for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )] t [[None, None, None, None, None, None, None, None, None], [None, None, None, None, None, None, None, None, None], [None, None, None, None, None, None, None, None, None], [None, None, None, None, None, None, None, None, None], [None, None, None, None, None, None, None, None, None]] after you've propery coded out the table wrap this into a function initt # we'll wrap the above into a function for ease of use def initt ( W , val ): return [[ None for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )]","title":"\ud83c\udf92 Exercise 1: Create the empty table as a list of lists"},{"location":"solutions/SOLN_P1_Stock_Cutting/#exercise-2-complete-the-function-knapsack-using-recursion-without-memoization","text":"Note that we need to think about how our indexing will work between the table, t , and our list representations of our items, wt and val . index 0 in our table means no items and no weight whereas in our list index 0 reprents item 1 so in the following knapsack function we need to shift all our indexing's of wt and val backwards by 1 (this is the difference between the code in the function and the mathematical representation in Section 1.2) def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 # now include the conditionals if wt [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( wt , val , w , n - 1 , t ), knapsack ( wt , val , w - wt [ n - 1 ], n - 1 , t ) + val [ n - 1 ]) return t [ n ][ w ] elif wt [ n - 1 ] > w : t [ n ][ w ] = knapsack ( wt , val , w , n - 1 , t ) return t [ n ][ w ] knapsack ( wt , val , W , len ( val ), t ) 8 If we look at the output of our table, we will see that it matches the one we described in Section 1.2 Value Weight 0 1 2 3 4 5 6 7 8 None None 0 0 0 0 0 0 0 0 0 1 2 0 0 1 1 1 1 1 1 1 2 3 0 0 1 2 2 3 3 3 3 5 4 0 0 1 2 5 5 6 6 7 6 5 0 0 1 2 5 6 6 7 8 it turns out that we did not have to visit every cell in the table however, to arrive at the optimal value of our knapsack: t [[None, None, None, None, None, None, None, None, None], [None, 0, None, 1, 1, 1, None, None, 1], [None, None, None, 2, 2, None, None, None, 3], [None, None, None, 2, None, None, None, None, 7], [None, None, None, None, None, None, None, None, 8]]","title":"\ud83c\udf92 Exercise 2: Complete the function knapsack using recursion without memoization"},{"location":"solutions/SOLN_P1_Stock_Cutting/#122-enrichment-use-memoization-to-speed-up-the-solution","text":"Memoization is a techniqued used along with recursion to create dynamic programms . We let our recursive algorithm know when we've already visited a subproblem by passing along a table (which in this case, we already have)","title":"1.2.2 Enrichment: use memoization to speed up the solution"},{"location":"solutions/SOLN_P1_Stock_Cutting/#exercise-3-check-if-we-have-already-visited-a-location-in-the-table","text":"def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != None : return t [ n ][ w ] # now include the conditionals if wt [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( wt , val , w , n - 1 , t ), knapsack ( wt , val , w - wt [ n - 1 ], n - 1 , t ) + val [ n - 1 ]) return t [ n ][ w ] elif wt [ n - 1 ] > w : t [ n ][ w ] = knapsack ( wt , val , w , n - 1 , t ) return t [ n ][ w ]","title":"\ud83c\udf92 Exercise 3: Check if we have already visited a location in the table"},{"location":"solutions/SOLN_P1_Stock_Cutting/#123-reconstruct-what-items-were-added-to-the-knapsack-by-reading-the-table","text":"The next part of the puzzle is to determine what items were added to the knapsack to achieve this optimal result! We can infer this from the table. Take a look at the table again, the algorithm we will envoke is that if the current cell's value does not appear in the previous row, it is because added that row's item! To see what else is in that hypothetical knapsack, we simply move up a row and left the number of columns equal to the last item we added, and repeat the process","title":"1.2.3 Reconstruct what items were added to the knapsack by reading the table"},{"location":"solutions/SOLN_P1_Stock_Cutting/#exercise-4-complete-the-pseudo-code-below-to-create-a-set-that-includes-all-the-items-in-the-knapsack","text":"recon = set () column = W # we will iterate through the rows of the table from bottom to top for row in range ( len ( val ))[:: - 1 ]: # we know that if the current cell value is not anywhere in the # previous row, it is because we added that item to the knapsack # remember that the table indexing is shifted forward compared to # the list indexes if t [ row + 1 ][ column ] not in t [ row ]: recon . add ( row ) # after we add the item, we need to adjust the weight the appropriate # number of steps column -= wt [ row ] # we will stop after we reach the 0th (no weight) column if column < 0 : break else : continue recon set()","title":"\ud83c\udf92 Exercise 4: Complete the pseudo code below to create a set that includes all the items in the knapsack"},{"location":"solutions/SOLN_P1_Stock_Cutting/#exercise-5-wrap-this-in-a-function-called-reconstruct","text":"we see that the output of the reconstruction are the second and fourth items (index starts at 0), which is what we expected! Let's package this into a function def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if t [ j + 1 ][ W ] not in t [ j ]: recon . add ( j ) W = W - wt [ j ] # move columns in table lookup if W < 0 : break else : continue return recon Now, to translate these indices to actual items we're going to use a function called Counter Dict subclass for counting hashable items. Sometimes called a bag or multiset. Elements are stored as dictionary keys and their counts are stored as dictionary values. We'll use Counter along with Numpy to take our indices/val list and count the number of times an item was used in the solution import numpy as np from collections import Counter sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ( np . array ( val )[ list ( sack )]) pattern sack {1, 3}","title":"\ud83c\udf92 Exercise 5: Wrap this in a function called reconstruct"},{"location":"solutions/SOLN_P1_Stock_Cutting/#13-unit-tests","text":"It is always good practice to test as we go. Let's make sure our algorithm works on some known subproblems def test_small_bag (): # the problem parameters val = [ 60 , 50 , 70 , 30 ] wt = [ 5 , 3 , 4 , 2 ] W = 5 # the known solution max_val = 80 max_items = [ 50 , 30 ] t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ( np . array ( val )[ list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert list ( pattern . keys ()) == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) test_small_bag () --------------------------------------------------------------------------- TypeError Traceback (most recent call last) c:\\Users\\Malek MFG\\pay\\deka\\notebooks\\solutions\\SOLN_P1_Stock_Cutting.ipynb Cell 31' in <cell line: 1>() ----> <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000030?line=0'>1</a> test_small_bag() c:\\Users\\Malek MFG\\pay\\deka\\notebooks\\solutions\\SOLN_P1_Stock_Cutting.ipynb Cell 30' in test_small_bag() <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000029?line=7'>8</a> max_val = 80 <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000029?line=8'>9</a> max_items = [50, 30] ---> <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000029?line=10'>11</a> t = initt(W, val) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000029?line=11'>12</a> best = knapsack(wt, val, W, len(val), t) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000029?line=12'>13</a> sack = reconstruct(len(val), W, t, wt) c:\\Users\\Malek MFG\\pay\\deka\\notebooks\\solutions\\SOLN_P1_Stock_Cutting.ipynb Cell 35' in initt(B, lens) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=55'>56</a> \"\"\" <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=56'>57</a> t, the returned table, will be a list of lists, but if transformed to <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=57'>58</a> an array it takes the shape of the number of products + 1 (len(s) + 1) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=58'>59</a> by the usable width + 1 (B + 1) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=59'>60</a> \"\"\" <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=60'>61</a> # We initialize the matrix with -1 at first. ---> <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=61'>62</a> return [[-1 for i in range(B + 1)] for j in range(lens + 1)] TypeError: can only concatenate list (not \"int\") to list def test_val_weight_equality (): # the problem parameters val = wt = [ 2 , 2 , 2 , 2 , 5 , 5 , 5 , 5 ] W = 14 # the known solution max_val = 14 max_items = Counter ([ 5 , 5 , 2 , 2 ]) t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ( np . array ( val )[ list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert pattern == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) test_val_weight_equality () --------------------------------------------------------------------------- TypeError Traceback (most recent call last) c:\\Users\\Malek MFG\\pay\\deka\\notebooks\\solutions\\SOLN_P1_Stock_Cutting.ipynb Cell 33' in <cell line: 1>() ----> <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000032?line=0'>1</a> test_val_weight_equality() c:\\Users\\Malek MFG\\pay\\deka\\notebooks\\solutions\\SOLN_P1_Stock_Cutting.ipynb Cell 32' in test_val_weight_equality() <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000031?line=6'>7</a> max_val = 14 <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000031?line=7'>8</a> max_items = Counter([5, 5, 2, 2]) ---> <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000031?line=9'>10</a> t = initt(W, val) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000031?line=10'>11</a> best = knapsack(wt, val, W, len(val), t) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000031?line=11'>12</a> sack = reconstruct(len(val), W, t, wt) c:\\Users\\Malek MFG\\pay\\deka\\notebooks\\solutions\\SOLN_P1_Stock_Cutting.ipynb Cell 35' in initt(B, lens) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=55'>56</a> \"\"\" <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=56'>57</a> t, the returned table, will be a list of lists, but if transformed to <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=57'>58</a> an array it takes the shape of the number of products + 1 (len(s) + 1) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=58'>59</a> by the usable width + 1 (B + 1) <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=59'>60</a> \"\"\" <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=60'>61</a> # We initialize the matrix with -1 at first. ---> <a href='vscode-notebook-cell:/c%3A/Users/Malek%20MFG/pay/deka/notebooks/solutions/SOLN_P1_Stock_Cutting.ipynb#ch0000034?line=61'>62</a> return [[-1 for i in range(B + 1)] for j in range(lens + 1)] TypeError: can only concatenate list (not \"int\") to list","title":"1.3 Unit Tests"},{"location":"solutions/SOLN_P1_Stock_Cutting/#14-save-our-functions","text":"import numpy as np from collections import Counter def knapsack ( wt , val , W , n , t ): \"\"\" in our particular case, the wt and val of the item are the same wt/val is 's' and is the items sorted by length, increasing wt: list the ordered weights (lengths of the rolls) val: list the ordered values (lengths of the rolls) W: int the weight of the current knapsack (the used length of the mother roll) n: int the number of items in the mother roll t: list of list the knapsack table \"\"\" # base conditions if n == 0 or W == 0 : # the first row and first column of the table is filled with 0s return 0 if t [ n ][ W ] != - 1 : # already solved at [n][W] return t [ n ][ W ] # choice diagram code if wt [ n - 1 ] <= W : # if the previous item under consideration is less than the current # weight left in the mother roll # we can now do 1 of 2 things add the new item in (and take the val # of the bag at the previous lvl w/o the item) (the answer to the left # in the table) plus the new wt/val or we use the best answer from one # fewer items at this weight lvl (the answer above the current cell in # the table) # t[n,w] = max{t[n-1,w], t[n-1, w-w[n-1]] + val[n-1]} # note that in the following wt and val are indexed starting at 0 # but t/knapsack is indexed starting at 1 (index 0 in the table is all # 0's) t [ n ][ W ] = max ( val [ n - 1 ] + knapsack ( wt , val , W - wt [ n - 1 ], n - 1 , t ), knapsack ( wt , val , W , n - 1 , t )) return t [ n ][ W ] elif wt [ n - 1 ] > W : # if wt/val of the current item under consideration is more than the # weight left in the bag, we've already found the best solution for # this number of items t [ n ][ W ] = knapsack ( wt , val , W , n - 1 , t ) return t [ n ][ W ] def initt ( B , lens ): \"\"\" t, the returned table, will be a list of lists, but if transformed to an array it takes the shape of the number of products + 1 (len(s) + 1) by the usable width + 1 (B + 1) \"\"\" # We initialize the matrix with -1 at first. return [[ - 1 for i in range ( B + 1 )] for j in range ( lens + 1 )] def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if t [ j + 1 , W ] not in t [ j ,:]: recon . add ( j ) W = W - wt [ j ] # move columns in table lookup if W < 0 : break else : continue return recon","title":"1.4 Save our functions"},{"location":"solutions/SOLN_P1_Stock_Cutting/#15-lab","text":"In the deka repository add our functions to enginge.py and our unit_tests to test_engine.py make sure you can run the tests via the Makefile","title":"1.5 Lab"},{"location":"solutions/SOLN_P2_Stock_Cutting/","text":"Stock Cutting Part 2: Finding Good (But not Best) Patterns \u00b6 In this project notebook we'll be leveraging our solution to the knapsack problem to create viable patterns for stock cutting. 1.0: Import Functions and Libraries \u00b6 from collections import Counter def initt ( W , val ): return [[ None for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )] def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != None : return t [ n ][ w ] # now include the conditionals if wt [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( wt , val , w , n - 1 , t ), knapsack ( wt , val , w - wt [ n - 1 ], n - 1 , t ) + val [ n - 1 ]) return t [ n ][ w ] elif wt [ n - 1 ] > w : t [ n ][ w ] = knapsack ( wt , val , w , n - 1 , t ) return t [ n ][ w ] def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if t [ j + 1 ][ W ] not in t [ j ]: recon . add ( j ) W = W - wt [ j ] # move columns in table lookup if W < 0 : break else : continue return recon def test_small_bag (): # the problem parameters val = [ 60 , 50 , 70 , 30 ] wt = [ 5 , 3 , 4 , 2 ] W = 5 # the known solution max_val = 80 max_items = [ 50 , 30 ] t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert list ( pattern . keys ()) == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_val_weight_equality (): # the problem parameters val = wt = [ 2 , 2 , 2 , 2 , 5 , 5 , 5 , 5 ] W = 14 # the known solution max_val = 14 max_items = Counter ([ 5 , 5 , 2 , 2 ]) t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert pattern == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) test_small_bag () Optimal value found Optimal items found test_val_weight_equality () Optimal value found Optimal items found 1.1 Modifications from knapsack to cutting stock \u00b6 You may have guessed this, but for all of our problems the wt list and val list will always be the same; they will be the list of widths scheduled to cut from stock. When we get our orders, we will need to adjust such that we are solving the appropriate problem with the knapsack function. To give an example, we might have 100 orders to fulfill with slitwidth 170. However we can max only fit 20 on a roll. In this situation, we don't want to include all 100 repeat widths in the knapsack problem, because we know we can't possibly fit that many. Instead, we want to only provide the maximum number of 170's we could possibly fit on a roll. This will make the algorithm more efficient. 1.1.1 Can we simplify the knapsack function? \u00b6 wt = val = [ 170 , 280 , 320 ] W = 4000 t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) pattern Counter({170: 1, 280: 1, 320: 1}) \ud83c\udf92 Exercise 1: replace wt and val in knapsack and nonetype in initt \u00b6 Notice how in the above cell we set wt and val equal to our product widths. In the cell below, rewrite the knapsack function so that widths takes the place of both wt and val def initt ( W , val ): return [[ - 1 for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )] def knapsack ( widths , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != - 1 : return t [ n ][ w ] # now include the conditionals if widths [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( widths , w , n - 1 , t ), knapsack ( widths , w - widths [ n - 1 ], n - 1 , t ) + widths [ n - 1 ]) return t [ n ][ w ] elif widths [ n - 1 ] > w : t [ n ][ w ] = knapsack ( widths , w , n - 1 , t ) return t [ n ][ w ] Do the same thing for the reconstruct function. And while we're at it, let's change N to n and W to w so that our variables are consistent across both functions def reconstruct ( n , w , t , widths ): recon = set () for j in range ( n )[:: - 1 ]: if t [ j + 1 ][ w ] not in t [ j ]: recon . add ( j ) w -= widths [ j ] # move columns in table lookup if w < 0 : break else : continue return recon and lets test our new functions widths = [ 170 , 280 , 320 ] W = 4000 t = initt ( W , widths ) best = knapsack ( widths , W , len ( widths ), t ) sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) pattern Counter({170: 1, 280: 1, 320: 1}) 1.1.2 How many slit widths? \u00b6 Does our answer to the knapsack problem above make sense? It does based on what we fed the function. However, in reality what we're looking for is the best pattern given a list of unique slit widths even if that requires repeating units of slit widths. So how do we modify the way we call the function? widths = [ 170 , 280 , 320 ] W = 4000 for w in widths : print ([ w ] * int ( W / w )) [170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170] [280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280] [320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320] \ud83c\udf92 Exercise 2: call knapsack with a modified list of widths \u00b6 In the above, we created new lists that properly signify the maximum number of units we could fit into the stock width. It is this list of items that we wish to feed into our knapsack problem. Rewrite our call to the knapsack problem below widths = [ 170 , 280 , 320 ] W = 4000 new = [] for w in widths : new += [ w ] * int ( W / w ) widths = new t = initt ( W , widths ) best = knapsack ( widths , W , len ( widths ), t ) print ( best ) sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) pattern 4000 Counter({170: 12, 280: 7}) \ud83c\udf92 Exercise 3: report the loss \u00b6 As a last adjustment, we want to think of the loss from a pattern, not the total number of millimeters used. Calculate the loss widths = [ 170 , 280 , 320 ] W = 4000 new = [] for w in widths : new += [ w ] * int ( W / w ) widths = new t = initt ( W , widths ) best = knapsack ( widths , W , len ( widths ), t ) loss = W - best print ( f \"Loss: { loss } \" ) sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) pattern Loss: 0 Counter({170: 12, 280: 7}) 1.2: Why good but not best? \u00b6 The shortcoming of the knapsack problem is that while it is able to find the best possible configuration to maximize the value of a knapsack, it does not consider constraints around items we must include. That is, when we create a schedule for our stock cutter, it is necessary that we deliver all orders within a reasonable time. To over come this hurdle, we combine results from the knapsack problem (and any other pattern generative algorithm we would like to include) with a linear opimization task. We will cover the linear optimization task in a later notebook. Just know for now that we are still working on creating candidate patterns. 1.2.1 Find all unique combinations of slit widths \u00b6 widths = [ 170 , 280 , 320 ] W = 4000 new = [] for w in widths : new += [ w ] * int ( W / w ) widths = new t = initt ( W , widths ) best = knapsack ( widths , W , len ( widths ), t ) loss = W - best print ( f \"Loss: { loss } \" ) sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) print ( pattern ) Loss: 0 Counter({170: 12, 280: 7}) \ud83c\udf92 Exercise 4: permutate the list of unique widths \u00b6 from itertools import combinations _widths = [ 170 , 280 , 320 ] W = 4000 max_unique_layouts = 3 def seed_patterns ( _widths , W , max_unique_layouts = 3 ): patterns = [] for current_max in range ( 1 , max_unique_layouts + 1 ): pre_sacks = list ( combinations ( _widths , current_max )) for widths in pre_sacks : new = [] for w in widths : new += [ w ] * int ( W / w ) widths = new t = initt ( W , widths ) best = knapsack ( widths , W , len ( widths ), t ) loss = W - best sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) patterns . append ([ pattern , loss ]) return patterns Call your function seed_patterns ( _widths , W ) [[Counter({170: 23}), 90], [Counter({280: 14}), 80], [Counter({320: 12}), 160], [Counter({170: 12, 280: 7}), 0], [Counter({170: 16, 320: 4}), 0], [Counter({280: 12, 320: 2}), 0], [Counter({170: 12, 280: 7}), 0]] For giggles, check the speed of your function using %%timeit %% timeit patterns = seed_patterns ( _widths , W ) 38 ms \u00b1 1.22 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each) 1.2.2 More permutations \u00b6 This is grand, but notice there are additional patterns that may be useful for our stock cutting problem. We were able to find: [Counter({280: 12, 320: 2}), 0], but notice how: [Counter({320: 9, 280: 4}), 0] is also a valid solution to fitting the two slit widths on stock. And in fact, the second solution may be one we need to produce our orders in as few stock rolls as possible. We'll come back to this question later on.","title":"Finding More Patterns"},{"location":"solutions/SOLN_P2_Stock_Cutting/#stock-cutting-part-2-finding-good-but-not-best-patterns","text":"In this project notebook we'll be leveraging our solution to the knapsack problem to create viable patterns for stock cutting.","title":"Stock Cutting Part 2: Finding Good (But not Best) Patterns"},{"location":"solutions/SOLN_P2_Stock_Cutting/#10-import-functions-and-libraries","text":"from collections import Counter def initt ( W , val ): return [[ None for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )] def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != None : return t [ n ][ w ] # now include the conditionals if wt [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( wt , val , w , n - 1 , t ), knapsack ( wt , val , w - wt [ n - 1 ], n - 1 , t ) + val [ n - 1 ]) return t [ n ][ w ] elif wt [ n - 1 ] > w : t [ n ][ w ] = knapsack ( wt , val , w , n - 1 , t ) return t [ n ][ w ] def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if t [ j + 1 ][ W ] not in t [ j ]: recon . add ( j ) W = W - wt [ j ] # move columns in table lookup if W < 0 : break else : continue return recon def test_small_bag (): # the problem parameters val = [ 60 , 50 , 70 , 30 ] wt = [ 5 , 3 , 4 , 2 ] W = 5 # the known solution max_val = 80 max_items = [ 50 , 30 ] t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert list ( pattern . keys ()) == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_val_weight_equality (): # the problem parameters val = wt = [ 2 , 2 , 2 , 2 , 5 , 5 , 5 , 5 ] W = 14 # the known solution max_val = 14 max_items = Counter ([ 5 , 5 , 2 , 2 ]) t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert pattern == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) test_small_bag () Optimal value found Optimal items found test_val_weight_equality () Optimal value found Optimal items found","title":"1.0: Import Functions and Libraries"},{"location":"solutions/SOLN_P2_Stock_Cutting/#11-modifications-from-knapsack-to-cutting-stock","text":"You may have guessed this, but for all of our problems the wt list and val list will always be the same; they will be the list of widths scheduled to cut from stock. When we get our orders, we will need to adjust such that we are solving the appropriate problem with the knapsack function. To give an example, we might have 100 orders to fulfill with slitwidth 170. However we can max only fit 20 on a roll. In this situation, we don't want to include all 100 repeat widths in the knapsack problem, because we know we can't possibly fit that many. Instead, we want to only provide the maximum number of 170's we could possibly fit on a roll. This will make the algorithm more efficient.","title":"1.1 Modifications from knapsack to cutting stock"},{"location":"solutions/SOLN_P2_Stock_Cutting/#111-can-we-simplify-the-knapsack-function","text":"wt = val = [ 170 , 280 , 320 ] W = 4000 t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) pattern Counter({170: 1, 280: 1, 320: 1})","title":"1.1.1 Can we simplify the knapsack function?"},{"location":"solutions/SOLN_P2_Stock_Cutting/#exercise-1-replace-wt-and-val-in-knapsack-and-nonetype-in-initt","text":"Notice how in the above cell we set wt and val equal to our product widths. In the cell below, rewrite the knapsack function so that widths takes the place of both wt and val def initt ( W , val ): return [[ - 1 for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )] def knapsack ( widths , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != - 1 : return t [ n ][ w ] # now include the conditionals if widths [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( widths , w , n - 1 , t ), knapsack ( widths , w - widths [ n - 1 ], n - 1 , t ) + widths [ n - 1 ]) return t [ n ][ w ] elif widths [ n - 1 ] > w : t [ n ][ w ] = knapsack ( widths , w , n - 1 , t ) return t [ n ][ w ] Do the same thing for the reconstruct function. And while we're at it, let's change N to n and W to w so that our variables are consistent across both functions def reconstruct ( n , w , t , widths ): recon = set () for j in range ( n )[:: - 1 ]: if t [ j + 1 ][ w ] not in t [ j ]: recon . add ( j ) w -= widths [ j ] # move columns in table lookup if w < 0 : break else : continue return recon and lets test our new functions widths = [ 170 , 280 , 320 ] W = 4000 t = initt ( W , widths ) best = knapsack ( widths , W , len ( widths ), t ) sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) pattern Counter({170: 1, 280: 1, 320: 1})","title":"\ud83c\udf92 Exercise 1: replace wt and val in knapsack and nonetype in initt"},{"location":"solutions/SOLN_P2_Stock_Cutting/#112-how-many-slit-widths","text":"Does our answer to the knapsack problem above make sense? It does based on what we fed the function. However, in reality what we're looking for is the best pattern given a list of unique slit widths even if that requires repeating units of slit widths. So how do we modify the way we call the function? widths = [ 170 , 280 , 320 ] W = 4000 for w in widths : print ([ w ] * int ( W / w )) [170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170] [280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280] [320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320]","title":"1.1.2 How many slit widths?"},{"location":"solutions/SOLN_P2_Stock_Cutting/#exercise-2-call-knapsack-with-a-modified-list-of-widths","text":"In the above, we created new lists that properly signify the maximum number of units we could fit into the stock width. It is this list of items that we wish to feed into our knapsack problem. Rewrite our call to the knapsack problem below widths = [ 170 , 280 , 320 ] W = 4000 new = [] for w in widths : new += [ w ] * int ( W / w ) widths = new t = initt ( W , widths ) best = knapsack ( widths , W , len ( widths ), t ) print ( best ) sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) pattern 4000 Counter({170: 12, 280: 7})","title":"\ud83c\udf92 Exercise 2: call knapsack with a modified list of widths"},{"location":"solutions/SOLN_P2_Stock_Cutting/#exercise-3-report-the-loss","text":"As a last adjustment, we want to think of the loss from a pattern, not the total number of millimeters used. Calculate the loss widths = [ 170 , 280 , 320 ] W = 4000 new = [] for w in widths : new += [ w ] * int ( W / w ) widths = new t = initt ( W , widths ) best = knapsack ( widths , W , len ( widths ), t ) loss = W - best print ( f \"Loss: { loss } \" ) sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) pattern Loss: 0 Counter({170: 12, 280: 7})","title":"\ud83c\udf92 Exercise 3: report the loss"},{"location":"solutions/SOLN_P2_Stock_Cutting/#12-why-good-but-not-best","text":"The shortcoming of the knapsack problem is that while it is able to find the best possible configuration to maximize the value of a knapsack, it does not consider constraints around items we must include. That is, when we create a schedule for our stock cutter, it is necessary that we deliver all orders within a reasonable time. To over come this hurdle, we combine results from the knapsack problem (and any other pattern generative algorithm we would like to include) with a linear opimization task. We will cover the linear optimization task in a later notebook. Just know for now that we are still working on creating candidate patterns.","title":"1.2: Why good but not best?"},{"location":"solutions/SOLN_P2_Stock_Cutting/#121-find-all-unique-combinations-of-slit-widths","text":"widths = [ 170 , 280 , 320 ] W = 4000 new = [] for w in widths : new += [ w ] * int ( W / w ) widths = new t = initt ( W , widths ) best = knapsack ( widths , W , len ( widths ), t ) loss = W - best print ( f \"Loss: { loss } \" ) sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) print ( pattern ) Loss: 0 Counter({170: 12, 280: 7})","title":"1.2.1 Find all unique combinations of slit widths"},{"location":"solutions/SOLN_P2_Stock_Cutting/#exercise-4-permutate-the-list-of-unique-widths","text":"from itertools import combinations _widths = [ 170 , 280 , 320 ] W = 4000 max_unique_layouts = 3 def seed_patterns ( _widths , W , max_unique_layouts = 3 ): patterns = [] for current_max in range ( 1 , max_unique_layouts + 1 ): pre_sacks = list ( combinations ( _widths , current_max )) for widths in pre_sacks : new = [] for w in widths : new += [ w ] * int ( W / w ) widths = new t = initt ( W , widths ) best = knapsack ( widths , W , len ( widths ), t ) loss = W - best sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) patterns . append ([ pattern , loss ]) return patterns Call your function seed_patterns ( _widths , W ) [[Counter({170: 23}), 90], [Counter({280: 14}), 80], [Counter({320: 12}), 160], [Counter({170: 12, 280: 7}), 0], [Counter({170: 16, 320: 4}), 0], [Counter({280: 12, 320: 2}), 0], [Counter({170: 12, 280: 7}), 0]] For giggles, check the speed of your function using %%timeit %% timeit patterns = seed_patterns ( _widths , W ) 38 ms \u00b1 1.22 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)","title":"\ud83c\udf92 Exercise 4: permutate the list of unique widths"},{"location":"solutions/SOLN_P2_Stock_Cutting/#122-more-permutations","text":"This is grand, but notice there are additional patterns that may be useful for our stock cutting problem. We were able to find: [Counter({280: 12, 320: 2}), 0], but notice how: [Counter({320: 9, 280: 4}), 0] is also a valid solution to fitting the two slit widths on stock. And in fact, the second solution may be one we need to produce our orders in as few stock rolls as possible. We'll come back to this question later on.","title":"1.2.2 More permutations"},{"location":"solutions/SOLN_P3_Stock_Cutting/","text":"Stock Cutting Part 3: The Column Generation Method \u00b6 In this project notebook we'll be combining our dynamic program from the knapsack problem with a strategy called the column generation method 1.0: Import Functions and Libraries \u00b6 from collections import Counter from itertools import combinations def seed_patterns ( _widths , W , max_unique_layouts = 3 ): patterns = [] for current_max in range ( 1 , max_unique_layouts + 1 ): pre_sacks = list ( combinations ( _widths , current_max )) for widths in pre_sacks : new = [] for w in widths : new += [ w ] * int ( W / w ) widths = new t = initt ( W , widths ) best = knapsack ( widths , widths , W , len ( widths ), t ) loss = W - best sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) patterns . append ([ pattern , loss ]) return patterns def initt ( W , val ): return [[ None for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )] def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != None : return t [ n ][ w ] # now include the conditionals if wt [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( wt , val , w , n - 1 , t ), knapsack ( wt , val , w - wt [ n - 1 ], n - 1 , t ) + val [ n - 1 ]) return t [ n ][ w ] elif wt [ n - 1 ] > w : t [ n ][ w ] = knapsack ( wt , val , w , n - 1 , t ) return t [ n ][ w ] def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if ( t [ j + 1 ][ W ] not in t [ j ]) and ( t [ j + 1 ][ W ] != 0 ): recon . add ( j ) W = W - wt [ j ] # move columns in table lookup if W < 0 : break else : continue return recon def test_small_bag (): # the problem parameters val = [ 60 , 50 , 70 , 30 ] wt = [ 5 , 3 , 4 , 2 ] W = 5 # the known solution max_val = 80 max_items = [ 50 , 30 ] t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert list ( pattern . keys ()) == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_val_weight_equality (): # the problem parameters val = wt = [ 2 , 2 , 2 , 2 , 5 , 5 , 5 , 5 ] W = 14 # the known solution max_val = 14 max_items = Counter ([ 5 , 5 , 2 , 2 ]) t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert pattern == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) test_small_bag () Optimal value found Optimal items found test_val_weight_equality () Optimal value found Optimal items found _widths = [ 170 , 280 , 320 ] W = 4000 max_unique_layouts = 3 seed_patterns ( _widths , W ) [[Counter({170: 23}), 90], [Counter({280: 14}), 80], [Counter({320: 12}), 160], [Counter({170: 12, 280: 7}), 0], [Counter({170: 16, 320: 4}), 0], [Counter({280: 12, 320: 2}), 0], [Counter({170: 12, 280: 7}), 0]] 2.0 The Restricted Master Problem (RMP) \u00b6 first we create our naieve solutions (restrict 1 layout per pattern) q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) patterns [[Counter({4: 3}), 3], [Counter({6: 2}), 3], [Counter({7: 2}), 1]] Then we perform the linear programming task. from scipy.optimize import linprog from math import ceil import numpy as np lhs_ineq = [] for pattern in patterns : # inset will be our full build of a given \"pattern\" inset = [] for width in widths : # try to access the slitwidth counts, otherwise # it means none of that slitwidth was included try : inset . append ( - pattern [ 0 ][ width ]) except : inset . append ( 0 ) # add inset to the set of equations (patterns) lhs_ineq . append ( inset ) lhs_ineq = np . array ( lhs_ineq ) . T . tolist () # rhs is the min orders we need for each slitwidth rhs_ineq = [ - i for i in q ] # min x1 + x2 + .... Xn obj = np . ones ( len ( lhs_ineq [ 0 ])) # linprog will determine the minimum number we need # of each pattern result = linprog ( c = obj , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) X = [ ceil ( i ) for i in result [ 'x' ]] print ( X ) print ( f \"total doffs: { sum ( X ) } \" ) [27, 25, 50] total doffs: 102 These values of X are the minimum doffs we need to fulfill our order quantities q given a set of patterns, patterns . The trick we next employee, is we determine how costly each width is to our solution. We do this by solving the dual variables of the linear program. The dual of a given linear program (LP) is another LP that is derived from the original (the primal) LP. Algorithmically this looks like the following: Each variable in the primal LP becomes a constraint in the dual LP Each constraint in the primal LP becomes a variable in the dual LP The objective direction is inversed \u2013 maximum in the primal becomes minimum in the dual and vice versa Notice below we switch the parameter fields for c and b_ub (the coefficients of the linear objective function and the linear constraint vector). And we take the negative transpose of our system of equations A_ub . dual_problem = linprog ( c = rhs_ineq , A_ub =- np . array ( lhs_ineq ) . T , b_ub = obj , method = \"revised simplex\" ) val = [ i for i in dual_problem [ 'x' ]] val [0.3333333333333333, 0.5, 0.5] Roughly, this outcome is similar to the number of doffs dedicated to each width, normalized by the quantity ordered for each width. (Note that this comparison is only approximately true but is meant to give a conceptual guide). [ i / j for i , j in zip ( X , q )] [0.3375, 0.5, 0.5] 3.0 The Column Generation Subproblem (CGSP) \u00b6 Ok. So what was that dual variable stuff all about? We are going to use the dual variable to update the value of each width. That's right, the behavior of each width in reference to the final doff quantities, X is used to bias the knapsack problem to give us a pattern that gives preferential treatment to the troublesome widths! wt = [ 4 , 6 , 7 ] W = 15 new_wt = [] new_val = [] for w , v in zip ( wt , val ): new_wt += [ w ] * int ( W / w ) new_val += [ v ] * int ( W / w ) wt = new_wt val = new_val t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) loss = W - best sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ wt [ i ] for i in list ( sack )]) print ( pattern ) value = Counter ([ val [ i ] for i in list ( sack )]) print ( value ) total = 0 for worth , multiple in value . items (): total += worth * multiple total > 1 Counter({4: 2, 6: 1}) Counter({0.3333333333333333: 2, 0.5: 1}) True The last conditional above, total > is our criteria for adding the new width to the growing host of patterns to then send to the RMP. If the total worth of the knapsack is greater than 1, this means our RMP will return a new solution with the added pattern that will result in overall fewer doffs. patterns . append ([ pattern , None ]) patterns [[Counter({4: 3}), 3], [Counter({6: 2}), 3], [Counter({7: 2}), 1], [Counter({4: 2, 6: 1}), None]] lhs_ineq = [] for pattern in patterns : # inset will be our full build of a given \"pattern\" inset = [] for width in widths : # try to access the slitwidth counts, otherwise # it means none of that slitwidth was included try : inset . append ( - pattern [ 0 ][ width ]) except : inset . append ( 0 ) # add inset to the set of equations (patterns) lhs_ineq . append ( inset ) lhs_ineq = np . array ( lhs_ineq ) . T . tolist () # rhs is the min orders we need for each slitwidth rhs_ineq = [ - i for i in q ] # min x1 + x2 + .... Xn obj = np . ones ( len ( lhs_ineq [ 0 ])) # linprog will determine the minimum number we need # of each pattern result = linprog ( c = obj , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) X = [ ceil ( i ) for i in result [ 'x' ]] print ( X ) [0, 5, 50, 41] we see that the total number of doffs is reduced from 102 to 96! print ( f \"total doffs: { sum ( X ) } \" ) total doffs: 96 dual_problem = linprog ( c = rhs_ineq , A_ub =- np . array ( lhs_ineq ) . T , b_ub = obj , method = \"revised simplex\" ) val = [ i for i in dual_problem [ 'x' ]] val [0.25, 0.5, 0.5] wt = [ 4 , 6 , 7 ] W = 15 new_wt = [] new_val = [] for w , v in zip ( wt , val ): new_wt += [ w ] * int ( W / w ) new_val += [ v ] * int ( W / w ) wt = new_wt val = new_val t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) loss = W - best sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ wt [ i ] for i in list ( sack )]) print ( pattern ) value = Counter ([ val [ i ] for i in list ( sack )]) print ( value ) total = 0 for worth , multiple in value . items (): total += worth * multiple total > 1 Counter({4: 2, 6: 1}) Counter({0.25: 2, 0.5: 1}) False In this case, the knapsack problem does not produce a knapsack with a value greater than 1, and so we discontinue our CGSP! total 1.0 4.0 Functions \u00b6 Let's bundle our code into some functions from scipy.optimize import linprog from math import ceil import numpy as np def solveX ( patterns , widths , q ): lhs_ineq = [] for pattern in patterns : # inset will be our full build of a given \"pattern\" inset = [] for width in widths : # try to access the slitwidth counts, otherwise # it means none of that slitwidth was included try : inset . append ( - pattern [ 0 ][ width ]) except : inset . append ( 0 ) # add inset to the set of equations (patterns) lhs_ineq . append ( inset ) lhs_ineq = np . array ( lhs_ineq ) . T . tolist () # rhs is the min orders we need for each slitwidth rhs_ineq = [ - i for i in q ] # min x1 + x2 + .... Xn obj = np . ones ( len ( lhs_ineq [ 0 ])) # linprog will determine the minimum number we need # of each pattern result = linprog ( c = obj , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) X = [ ceil ( i ) for i in result [ 'x' ]] dual_problem = linprog ( c = rhs_ineq , A_ub =- np . array ( lhs_ineq ) . T , b_ub = obj , method = \"revised simplex\" ) val = [ i for i in dual_problem [ 'x' ]] return X , val def pack_knap ( wt , val , W ): new_wt = [] new_val = [] for w , v in zip ( wt , val ): new_wt += [ w ] * int ( W / w ) new_val += [ v ] * int ( W / w ) wt = new_wt val = new_val t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) loss = W - best sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ wt [ i ] for i in list ( sack )]) value = Counter ([ val [ i ] for i in list ( sack )]) total = 0 for worth , multiple in value . items (): total += worth * multiple return pattern , total Starting over with the former example... We seed our patterns with the naive solutions q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) patterns [[Counter({4: 3}), 3], [Counter({6: 2}), 3], [Counter({7: 2}), 1]] We solve the RMP X , val = solveX ( patterns , widths , q ) print ( sum ( X )) print ( X , val ) 102 [27, 25, 50] [0.3333333333333333, 0.5, 0.5] We solve the CGSP pattern , total = pack_knap ( w , val , W ) print ( pattern , total ) print ( total > 1 ) Counter({4: 2, 6: 1}) 1.1666666666666665 True Since the value is greater than 1 we add the pattern to our linprog and solve the RMP again patterns . append ([ pattern , 0 ]) X , val = solveX ( patterns , widths , q ) print ( sum ( X )) print ( X , val ) pattern , total = pack_knap ( w , val , W ) print ( pattern , total ) print ( total > 1 ) 96 [0, 5, 50, 41] [0.25, 0.5, 0.5] Counter({4: 2, 6: 1}) 1.0 False We exit when we can no longer find a pattern that would improve the RMP 5.0 All Together Now \u00b6 q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) while True : X , val = solveX ( patterns , widths , q ) pattern , total = pack_knap ( w , val , W ) if total > 1 : patterns . append ([ pattern , 0 ]) continue break print () print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) total doffs: 96 5, Counter({6: 2}) 50, Counter({7: 2}) 41, Counter({4: 2, 6: 1})","title":"The Column Generation Method"},{"location":"solutions/SOLN_P3_Stock_Cutting/#stock-cutting-part-3-the-column-generation-method","text":"In this project notebook we'll be combining our dynamic program from the knapsack problem with a strategy called the column generation method","title":"Stock Cutting Part 3: The Column Generation Method"},{"location":"solutions/SOLN_P3_Stock_Cutting/#10-import-functions-and-libraries","text":"from collections import Counter from itertools import combinations def seed_patterns ( _widths , W , max_unique_layouts = 3 ): patterns = [] for current_max in range ( 1 , max_unique_layouts + 1 ): pre_sacks = list ( combinations ( _widths , current_max )) for widths in pre_sacks : new = [] for w in widths : new += [ w ] * int ( W / w ) widths = new t = initt ( W , widths ) best = knapsack ( widths , widths , W , len ( widths ), t ) loss = W - best sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) patterns . append ([ pattern , loss ]) return patterns def initt ( W , val ): return [[ None for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )] def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != None : return t [ n ][ w ] # now include the conditionals if wt [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( wt , val , w , n - 1 , t ), knapsack ( wt , val , w - wt [ n - 1 ], n - 1 , t ) + val [ n - 1 ]) return t [ n ][ w ] elif wt [ n - 1 ] > w : t [ n ][ w ] = knapsack ( wt , val , w , n - 1 , t ) return t [ n ][ w ] def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if ( t [ j + 1 ][ W ] not in t [ j ]) and ( t [ j + 1 ][ W ] != 0 ): recon . add ( j ) W = W - wt [ j ] # move columns in table lookup if W < 0 : break else : continue return recon def test_small_bag (): # the problem parameters val = [ 60 , 50 , 70 , 30 ] wt = [ 5 , 3 , 4 , 2 ] W = 5 # the known solution max_val = 80 max_items = [ 50 , 30 ] t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert list ( pattern . keys ()) == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_val_weight_equality (): # the problem parameters val = wt = [ 2 , 2 , 2 , 2 , 5 , 5 , 5 , 5 ] W = 14 # the known solution max_val = 14 max_items = Counter ([ 5 , 5 , 2 , 2 ]) t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert pattern == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) test_small_bag () Optimal value found Optimal items found test_val_weight_equality () Optimal value found Optimal items found _widths = [ 170 , 280 , 320 ] W = 4000 max_unique_layouts = 3 seed_patterns ( _widths , W ) [[Counter({170: 23}), 90], [Counter({280: 14}), 80], [Counter({320: 12}), 160], [Counter({170: 12, 280: 7}), 0], [Counter({170: 16, 320: 4}), 0], [Counter({280: 12, 320: 2}), 0], [Counter({170: 12, 280: 7}), 0]]","title":"1.0: Import Functions and Libraries"},{"location":"solutions/SOLN_P3_Stock_Cutting/#20-the-restricted-master-problem-rmp","text":"first we create our naieve solutions (restrict 1 layout per pattern) q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) patterns [[Counter({4: 3}), 3], [Counter({6: 2}), 3], [Counter({7: 2}), 1]] Then we perform the linear programming task. from scipy.optimize import linprog from math import ceil import numpy as np lhs_ineq = [] for pattern in patterns : # inset will be our full build of a given \"pattern\" inset = [] for width in widths : # try to access the slitwidth counts, otherwise # it means none of that slitwidth was included try : inset . append ( - pattern [ 0 ][ width ]) except : inset . append ( 0 ) # add inset to the set of equations (patterns) lhs_ineq . append ( inset ) lhs_ineq = np . array ( lhs_ineq ) . T . tolist () # rhs is the min orders we need for each slitwidth rhs_ineq = [ - i for i in q ] # min x1 + x2 + .... Xn obj = np . ones ( len ( lhs_ineq [ 0 ])) # linprog will determine the minimum number we need # of each pattern result = linprog ( c = obj , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) X = [ ceil ( i ) for i in result [ 'x' ]] print ( X ) print ( f \"total doffs: { sum ( X ) } \" ) [27, 25, 50] total doffs: 102 These values of X are the minimum doffs we need to fulfill our order quantities q given a set of patterns, patterns . The trick we next employee, is we determine how costly each width is to our solution. We do this by solving the dual variables of the linear program. The dual of a given linear program (LP) is another LP that is derived from the original (the primal) LP. Algorithmically this looks like the following: Each variable in the primal LP becomes a constraint in the dual LP Each constraint in the primal LP becomes a variable in the dual LP The objective direction is inversed \u2013 maximum in the primal becomes minimum in the dual and vice versa Notice below we switch the parameter fields for c and b_ub (the coefficients of the linear objective function and the linear constraint vector). And we take the negative transpose of our system of equations A_ub . dual_problem = linprog ( c = rhs_ineq , A_ub =- np . array ( lhs_ineq ) . T , b_ub = obj , method = \"revised simplex\" ) val = [ i for i in dual_problem [ 'x' ]] val [0.3333333333333333, 0.5, 0.5] Roughly, this outcome is similar to the number of doffs dedicated to each width, normalized by the quantity ordered for each width. (Note that this comparison is only approximately true but is meant to give a conceptual guide). [ i / j for i , j in zip ( X , q )] [0.3375, 0.5, 0.5]","title":"2.0 The Restricted Master Problem (RMP)"},{"location":"solutions/SOLN_P3_Stock_Cutting/#30-the-column-generation-subproblem-cgsp","text":"Ok. So what was that dual variable stuff all about? We are going to use the dual variable to update the value of each width. That's right, the behavior of each width in reference to the final doff quantities, X is used to bias the knapsack problem to give us a pattern that gives preferential treatment to the troublesome widths! wt = [ 4 , 6 , 7 ] W = 15 new_wt = [] new_val = [] for w , v in zip ( wt , val ): new_wt += [ w ] * int ( W / w ) new_val += [ v ] * int ( W / w ) wt = new_wt val = new_val t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) loss = W - best sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ wt [ i ] for i in list ( sack )]) print ( pattern ) value = Counter ([ val [ i ] for i in list ( sack )]) print ( value ) total = 0 for worth , multiple in value . items (): total += worth * multiple total > 1 Counter({4: 2, 6: 1}) Counter({0.3333333333333333: 2, 0.5: 1}) True The last conditional above, total > is our criteria for adding the new width to the growing host of patterns to then send to the RMP. If the total worth of the knapsack is greater than 1, this means our RMP will return a new solution with the added pattern that will result in overall fewer doffs. patterns . append ([ pattern , None ]) patterns [[Counter({4: 3}), 3], [Counter({6: 2}), 3], [Counter({7: 2}), 1], [Counter({4: 2, 6: 1}), None]] lhs_ineq = [] for pattern in patterns : # inset will be our full build of a given \"pattern\" inset = [] for width in widths : # try to access the slitwidth counts, otherwise # it means none of that slitwidth was included try : inset . append ( - pattern [ 0 ][ width ]) except : inset . append ( 0 ) # add inset to the set of equations (patterns) lhs_ineq . append ( inset ) lhs_ineq = np . array ( lhs_ineq ) . T . tolist () # rhs is the min orders we need for each slitwidth rhs_ineq = [ - i for i in q ] # min x1 + x2 + .... Xn obj = np . ones ( len ( lhs_ineq [ 0 ])) # linprog will determine the minimum number we need # of each pattern result = linprog ( c = obj , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) X = [ ceil ( i ) for i in result [ 'x' ]] print ( X ) [0, 5, 50, 41] we see that the total number of doffs is reduced from 102 to 96! print ( f \"total doffs: { sum ( X ) } \" ) total doffs: 96 dual_problem = linprog ( c = rhs_ineq , A_ub =- np . array ( lhs_ineq ) . T , b_ub = obj , method = \"revised simplex\" ) val = [ i for i in dual_problem [ 'x' ]] val [0.25, 0.5, 0.5] wt = [ 4 , 6 , 7 ] W = 15 new_wt = [] new_val = [] for w , v in zip ( wt , val ): new_wt += [ w ] * int ( W / w ) new_val += [ v ] * int ( W / w ) wt = new_wt val = new_val t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) loss = W - best sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ wt [ i ] for i in list ( sack )]) print ( pattern ) value = Counter ([ val [ i ] for i in list ( sack )]) print ( value ) total = 0 for worth , multiple in value . items (): total += worth * multiple total > 1 Counter({4: 2, 6: 1}) Counter({0.25: 2, 0.5: 1}) False In this case, the knapsack problem does not produce a knapsack with a value greater than 1, and so we discontinue our CGSP! total 1.0","title":"3.0 The Column Generation Subproblem (CGSP)"},{"location":"solutions/SOLN_P3_Stock_Cutting/#40-functions","text":"Let's bundle our code into some functions from scipy.optimize import linprog from math import ceil import numpy as np def solveX ( patterns , widths , q ): lhs_ineq = [] for pattern in patterns : # inset will be our full build of a given \"pattern\" inset = [] for width in widths : # try to access the slitwidth counts, otherwise # it means none of that slitwidth was included try : inset . append ( - pattern [ 0 ][ width ]) except : inset . append ( 0 ) # add inset to the set of equations (patterns) lhs_ineq . append ( inset ) lhs_ineq = np . array ( lhs_ineq ) . T . tolist () # rhs is the min orders we need for each slitwidth rhs_ineq = [ - i for i in q ] # min x1 + x2 + .... Xn obj = np . ones ( len ( lhs_ineq [ 0 ])) # linprog will determine the minimum number we need # of each pattern result = linprog ( c = obj , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) X = [ ceil ( i ) for i in result [ 'x' ]] dual_problem = linprog ( c = rhs_ineq , A_ub =- np . array ( lhs_ineq ) . T , b_ub = obj , method = \"revised simplex\" ) val = [ i for i in dual_problem [ 'x' ]] return X , val def pack_knap ( wt , val , W ): new_wt = [] new_val = [] for w , v in zip ( wt , val ): new_wt += [ w ] * int ( W / w ) new_val += [ v ] * int ( W / w ) wt = new_wt val = new_val t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) loss = W - best sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ wt [ i ] for i in list ( sack )]) value = Counter ([ val [ i ] for i in list ( sack )]) total = 0 for worth , multiple in value . items (): total += worth * multiple return pattern , total Starting over with the former example... We seed our patterns with the naive solutions q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) patterns [[Counter({4: 3}), 3], [Counter({6: 2}), 3], [Counter({7: 2}), 1]] We solve the RMP X , val = solveX ( patterns , widths , q ) print ( sum ( X )) print ( X , val ) 102 [27, 25, 50] [0.3333333333333333, 0.5, 0.5] We solve the CGSP pattern , total = pack_knap ( w , val , W ) print ( pattern , total ) print ( total > 1 ) Counter({4: 2, 6: 1}) 1.1666666666666665 True Since the value is greater than 1 we add the pattern to our linprog and solve the RMP again patterns . append ([ pattern , 0 ]) X , val = solveX ( patterns , widths , q ) print ( sum ( X )) print ( X , val ) pattern , total = pack_knap ( w , val , W ) print ( pattern , total ) print ( total > 1 ) 96 [0, 5, 50, 41] [0.25, 0.5, 0.5] Counter({4: 2, 6: 1}) 1.0 False We exit when we can no longer find a pattern that would improve the RMP","title":"4.0 Functions"},{"location":"solutions/SOLN_P3_Stock_Cutting/#50-all-together-now","text":"q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) while True : X , val = solveX ( patterns , widths , q ) pattern , total = pack_knap ( w , val , W ) if total > 1 : patterns . append ([ pattern , 0 ]) continue break print () print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) total doffs: 96 5, Counter({6: 2}) 50, Counter({7: 2}) 41, Counter({4: 2, 6: 1})","title":"5.0 All Together Now"},{"location":"solutions/SOLN_P4_Stock_Cutting/","text":"Stock Cutting Part 4: Unit Tests \u00b6 In this project notebook we'll be writing unit tests for our cutting stock algorithm 1.0: Import Functions and Libraries \u00b6 from collections import Counter from itertools import combinations from scipy.optimize import linprog from math import ceil import numpy as np def solveX ( patterns , widths , q ): \"\"\" solves the linprog (minimum doffs needed given set of patterns) as well as the dual problem \"\"\" lhs_ineq = [] for pattern in patterns : # inset will be our full build of a given \"pattern\" inset = [] for width in widths : # try to access the slitwidth counts, otherwise # it means none of that slitwidth was included try : inset . append ( - pattern [ 0 ][ width ]) except : inset . append ( 0 ) # add inset to the set of equations (patterns) lhs_ineq . append ( inset ) lhs_ineq = np . array ( lhs_ineq ) . T . tolist () # rhs is the min orders we need for each slitwidth rhs_ineq = [ - i for i in q ] # min x1 + x2 + .... Xn obj = np . ones ( len ( lhs_ineq [ 0 ])) # linprog will determine the minimum number we need # of each pattern result = linprog ( c = obj , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) X = [ ceil ( i ) for i in result [ 'x' ]] dual_problem = linprog ( c = rhs_ineq , A_ub =- np . array ( lhs_ineq ) . T , b_ub = obj , method = \"revised simplex\" ) val = [ i for i in dual_problem [ 'x' ]] return X , val def pack_knap ( wt , val , W ): new_wt = [] new_val = [] for w , v in zip ( wt , val ): new_wt += [ w ] * int ( W / w ) new_val += [ v ] * int ( W / w ) wt = new_wt val = new_val t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) loss = W - best sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ wt [ i ] for i in list ( sack )]) value = Counter ([ val [ i ] for i in list ( sack )]) total = 0 for worth , multiple in value . items (): total += worth * multiple return pattern , total def seed_patterns ( _widths , W , max_unique_layouts = 3 ): patterns = [] for current_max in range ( 1 , max_unique_layouts + 1 ): pre_sacks = list ( combinations ( _widths , current_max )) for widths in pre_sacks : new = [] for w in widths : new += [ w ] * int ( W / w ) widths = new t = initt ( W , widths ) best = knapsack ( widths , widths , W , len ( widths ), t ) loss = W - best sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) patterns . append ([ pattern , loss ]) return patterns def initt ( W , val ): return [[ None for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )] def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != None : return t [ n ][ w ] # now include the conditionals if wt [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( wt , val , w , n - 1 , t ), knapsack ( wt , val , w - wt [ n - 1 ], n - 1 , t ) + val [ n - 1 ]) return t [ n ][ w ] elif wt [ n - 1 ] > w : t [ n ][ w ] = knapsack ( wt , val , w , n - 1 , t ) return t [ n ][ w ] def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if ( t [ j + 1 ][ W ] not in t [ j ]) and ( t [ j + 1 ][ W ] != 0 ): recon . add ( j ) W = W - wt [ j ] # move columns in table lookup if W < 0 : break else : continue return recon def test_small_bag (): # the problem parameters val = [ 60 , 50 , 70 , 30 ] wt = [ 5 , 3 , 4 , 2 ] W = 5 # the known solution max_val = 80 max_items = [ 50 , 30 ] t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert list ( pattern . keys ()) == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_val_weight_equality (): # the problem parameters val = wt = [ 2 , 2 , 2 , 2 , 5 , 5 , 5 , 5 ] W = 14 # the known solution max_val = 14 max_items = Counter ([ 5 , 5 , 2 , 2 ]) t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert pattern == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_simple_stock_cutting (): q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 ans = 96 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) while True : X , val = solveX ( patterns , widths , q ) pattern , total = pack_knap ( w , val , W ) if total > 1 : patterns . append ([ pattern , 0 ]) continue break assert sum ( X ) == ans , \"Optimal doffs not found\" print ( \"test passed\" ) print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) test_simple_stock_cutting () test passed total doffs: 96 5, Counter({6: 2}) 50, Counter({7: 2}) 41, Counter({4: 2, 6: 1}) ( 12 * 234 + 8 * 158 ) 4072 print ( f \"234: { 17 * 7 + 3 * 44 } \" ) print ( f \"170: { 20 * 44 } \" ) print ( f \"158: { 26 * 7 } \" ) 234: 251 170: 880 158: 182 # [879, 244, 181] print ( f \"234: { ( 17 * 7 + 3 * 44 ) / 244 } \" ) print ( f \"170: { ( 20 * 44 ) / 879 } \" ) print ( f \"158: { ( 26 * 7 ) / 181 } \" ) 234: 1.028688524590164 170: 1.0011376564277588 158: 1.0055248618784531 ((( 17 * 7 + 3 * 44 ) + ( 20 * 44 ) + ( 26 * 7 )) / ( 244 + 879 + 181 )) * 100 100.69018404907975 print ( f \" { 4160 - 236 * 17 } \" ) print ( f \" { 4160 - ( 20 * 172 + 3 * 236 ) } \" ) print ( f \" { 4160 - 26 * 160 } \" ) 148 12 0 # q = [448, 931, 2179, 864] # widths = [218, 170, 234, 208] # W = 1500 widths = [ i + j for i , j in zip ([ 2 , 2 , 2 ], [ 170 , 234 , 158 ])] q = [ 879 , 244 , 181 ] W = 4160 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) while True : X , val = solveX ( patterns , widths , q ) pattern , total = pack_knap ( widths , val , W ) if total > 1 : patterns . append ([ pattern , 0 ]) continue break print ( \"test passed\" ) print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) test passed total doffs: 59 39, Counter({172: 20, 160: 3, 236: 1}) 16, Counter({236: 12, 172: 4, 160: 4}) 4, Counter({172: 15, 236: 6, 160: 1}) ( 16 * 170 + 6 * 234 ) 4124 ( 14 * 170 + 11 * 158 ) 4118 # let's clean up these answers # target is an input - needs ot be made an outpu (i.e. shows % above or below the order quantity) # remove answers that are outside of +/- 10% # show devops process on docker, cli, azure app service","title":"Unit Tests"},{"location":"solutions/SOLN_P4_Stock_Cutting/#stock-cutting-part-4-unit-tests","text":"In this project notebook we'll be writing unit tests for our cutting stock algorithm","title":"Stock Cutting Part 4: Unit Tests"},{"location":"solutions/SOLN_P4_Stock_Cutting/#10-import-functions-and-libraries","text":"from collections import Counter from itertools import combinations from scipy.optimize import linprog from math import ceil import numpy as np def solveX ( patterns , widths , q ): \"\"\" solves the linprog (minimum doffs needed given set of patterns) as well as the dual problem \"\"\" lhs_ineq = [] for pattern in patterns : # inset will be our full build of a given \"pattern\" inset = [] for width in widths : # try to access the slitwidth counts, otherwise # it means none of that slitwidth was included try : inset . append ( - pattern [ 0 ][ width ]) except : inset . append ( 0 ) # add inset to the set of equations (patterns) lhs_ineq . append ( inset ) lhs_ineq = np . array ( lhs_ineq ) . T . tolist () # rhs is the min orders we need for each slitwidth rhs_ineq = [ - i for i in q ] # min x1 + x2 + .... Xn obj = np . ones ( len ( lhs_ineq [ 0 ])) # linprog will determine the minimum number we need # of each pattern result = linprog ( c = obj , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) X = [ ceil ( i ) for i in result [ 'x' ]] dual_problem = linprog ( c = rhs_ineq , A_ub =- np . array ( lhs_ineq ) . T , b_ub = obj , method = \"revised simplex\" ) val = [ i for i in dual_problem [ 'x' ]] return X , val def pack_knap ( wt , val , W ): new_wt = [] new_val = [] for w , v in zip ( wt , val ): new_wt += [ w ] * int ( W / w ) new_val += [ v ] * int ( W / w ) wt = new_wt val = new_val t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) loss = W - best sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ wt [ i ] for i in list ( sack )]) value = Counter ([ val [ i ] for i in list ( sack )]) total = 0 for worth , multiple in value . items (): total += worth * multiple return pattern , total def seed_patterns ( _widths , W , max_unique_layouts = 3 ): patterns = [] for current_max in range ( 1 , max_unique_layouts + 1 ): pre_sacks = list ( combinations ( _widths , current_max )) for widths in pre_sacks : new = [] for w in widths : new += [ w ] * int ( W / w ) widths = new t = initt ( W , widths ) best = knapsack ( widths , widths , W , len ( widths ), t ) loss = W - best sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) patterns . append ([ pattern , loss ]) return patterns def initt ( W , val ): return [[ None for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )] def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != None : return t [ n ][ w ] # now include the conditionals if wt [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( wt , val , w , n - 1 , t ), knapsack ( wt , val , w - wt [ n - 1 ], n - 1 , t ) + val [ n - 1 ]) return t [ n ][ w ] elif wt [ n - 1 ] > w : t [ n ][ w ] = knapsack ( wt , val , w , n - 1 , t ) return t [ n ][ w ] def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if ( t [ j + 1 ][ W ] not in t [ j ]) and ( t [ j + 1 ][ W ] != 0 ): recon . add ( j ) W = W - wt [ j ] # move columns in table lookup if W < 0 : break else : continue return recon def test_small_bag (): # the problem parameters val = [ 60 , 50 , 70 , 30 ] wt = [ 5 , 3 , 4 , 2 ] W = 5 # the known solution max_val = 80 max_items = [ 50 , 30 ] t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert list ( pattern . keys ()) == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_val_weight_equality (): # the problem parameters val = wt = [ 2 , 2 , 2 , 2 , 5 , 5 , 5 , 5 ] W = 14 # the known solution max_val = 14 max_items = Counter ([ 5 , 5 , 2 , 2 ]) t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert pattern == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_simple_stock_cutting (): q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 ans = 96 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) while True : X , val = solveX ( patterns , widths , q ) pattern , total = pack_knap ( w , val , W ) if total > 1 : patterns . append ([ pattern , 0 ]) continue break assert sum ( X ) == ans , \"Optimal doffs not found\" print ( \"test passed\" ) print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) test_simple_stock_cutting () test passed total doffs: 96 5, Counter({6: 2}) 50, Counter({7: 2}) 41, Counter({4: 2, 6: 1}) ( 12 * 234 + 8 * 158 ) 4072 print ( f \"234: { 17 * 7 + 3 * 44 } \" ) print ( f \"170: { 20 * 44 } \" ) print ( f \"158: { 26 * 7 } \" ) 234: 251 170: 880 158: 182 # [879, 244, 181] print ( f \"234: { ( 17 * 7 + 3 * 44 ) / 244 } \" ) print ( f \"170: { ( 20 * 44 ) / 879 } \" ) print ( f \"158: { ( 26 * 7 ) / 181 } \" ) 234: 1.028688524590164 170: 1.0011376564277588 158: 1.0055248618784531 ((( 17 * 7 + 3 * 44 ) + ( 20 * 44 ) + ( 26 * 7 )) / ( 244 + 879 + 181 )) * 100 100.69018404907975 print ( f \" { 4160 - 236 * 17 } \" ) print ( f \" { 4160 - ( 20 * 172 + 3 * 236 ) } \" ) print ( f \" { 4160 - 26 * 160 } \" ) 148 12 0 # q = [448, 931, 2179, 864] # widths = [218, 170, 234, 208] # W = 1500 widths = [ i + j for i , j in zip ([ 2 , 2 , 2 ], [ 170 , 234 , 158 ])] q = [ 879 , 244 , 181 ] W = 4160 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) while True : X , val = solveX ( patterns , widths , q ) pattern , total = pack_knap ( widths , val , W ) if total > 1 : patterns . append ([ pattern , 0 ]) continue break print ( \"test passed\" ) print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) test passed total doffs: 59 39, Counter({172: 20, 160: 3, 236: 1}) 16, Counter({236: 12, 172: 4, 160: 4}) 4, Counter({172: 15, 236: 6, 160: 1}) ( 16 * 170 + 6 * 234 ) 4124 ( 14 * 170 + 11 * 158 ) 4118 # let's clean up these answers # target is an input - needs ot be made an outpu (i.e. shows % above or below the order quantity) # remove answers that are outside of +/- 10% # show devops process on docker, cli, azure app service","title":"1.0: Import Functions and Libraries"},{"location":"solutions/SOLN_P5_Stock_Cutting/","text":"Stock Cutting Part 5: Edge Cases \u00b6 In this project notebook we'll be exploring edge cases. Specifically, how do we use the building blocks we've created so far to account for user restrictions on layouts and patterns. 1: Import Functions and Libraries \u00b6 from collections import Counter from itertools import combinations from scipy.optimize import linprog from math import ceil import numpy as np def solveX ( patterns , widths , q ): \"\"\" solves the linprog (minimum doffs needed given set of patterns) as well as the dual problem \"\"\" lhs_ineq = [] for pattern in patterns : # inset will be our full build of a given \"pattern\" inset = [] for width in widths : # try to access the slitwidth counts, otherwise # it means none of that slitwidth was included try : inset . append ( - pattern [ 0 ][ width ]) except : inset . append ( 0 ) # add inset to the set of equations (patterns) lhs_ineq . append ( inset ) lhs_ineq = np . array ( lhs_ineq ) . T . tolist () # rhs is the min orders we need for each slitwidth rhs_ineq = [ - i for i in q ] # min x1 + x2 + .... Xn obj = np . ones ( len ( lhs_ineq [ 0 ])) # linprog will determine the minimum number we need # of each pattern result = linprog ( c = obj , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) X = [ ceil ( i ) for i in result [ 'x' ]] dual_problem = linprog ( c = rhs_ineq , A_ub =- np . array ( lhs_ineq ) . T , b_ub = obj , method = \"revised simplex\" ) val = [ i for i in dual_problem [ 'x' ]] return X , val def pack_knap ( wt , val , W ): new_wt = [] new_val = [] for w , v in zip ( wt , val ): new_wt += [ w ] * int ( W / w ) new_val += [ v ] * int ( W / w ) wt = new_wt val = new_val t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) loss = W - best sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ wt [ i ] for i in list ( sack )]) value = Counter ([ val [ i ] for i in list ( sack )]) total = 0 for worth , multiple in value . items (): total += worth * multiple return pattern , total def seed_patterns ( _widths , W , max_unique_layouts = 3 ): patterns = [] for current_max in range ( 1 , max_unique_layouts + 1 ): pre_sacks = list ( combinations ( _widths , current_max )) for widths in pre_sacks : new = [] for w in widths : new += [ w ] * int ( W / w ) widths = new t = initt ( W , widths ) best = knapsack ( widths , widths , W , len ( widths ), t ) loss = W - best sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) if [ pattern , loss ] not in patterns : patterns . append ([ pattern , loss ]) return patterns def initt ( W , val ): return [[ None for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )] def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != None : return t [ n ][ w ] # now include the conditionals if wt [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( wt , val , w , n - 1 , t ), knapsack ( wt , val , w - wt [ n - 1 ], n - 1 , t ) + val [ n - 1 ]) return t [ n ][ w ] elif wt [ n - 1 ] > w : t [ n ][ w ] = knapsack ( wt , val , w , n - 1 , t ) return t [ n ][ w ] def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if ( t [ j + 1 ][ W ] not in t [ j ]) and ( t [ j + 1 ][ W ] != 0 ): recon . add ( j ) W = W - wt [ j ] # move columns in table lookup if W < 0 : break else : continue return recon def test_small_bag (): # the problem parameters val = [ 60 , 50 , 70 , 30 ] wt = [ 5 , 3 , 4 , 2 ] W = 5 # the known solution max_val = 80 max_items = [ 50 , 30 ] t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert list ( pattern . keys ()) == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_val_weight_equality (): # the problem parameters val = wt = [ 2 , 2 , 2 , 2 , 5 , 5 , 5 , 5 ] W = 14 # the known solution max_val = 14 max_items = Counter ([ 5 , 5 , 2 , 2 ]) t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert pattern == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_simple_stock_cutting (): q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 ans = 96 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) while True : X , val = solveX ( patterns , widths , q ) pattern , total = pack_knap ( w , val , W ) if total > 1 : patterns . append ([ pattern , 0 ]) continue break assert sum ( X ) == ans , \"Optimal doffs not found\" print ( \"test passed\" ) print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) def test_stock_cutting_2 (): widths = [ i + j for i , j in zip ([ 2 , 2 , 2 ], [ 170 , 234 , 158 ])] q = [ 879 , 244 , 181 ] W = 4160 ans = 59 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) while True : X , val = solveX ( patterns , widths , q ) pattern , total = pack_knap ( widths , val , W ) if total > 1 : patterns . append ([ pattern , 0 ]) continue break assert sum ( X ) == ans , \"Optimal doffs not found\" print ( \"test passed\" ) print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) run tests test_val_weight_equality () print () test_small_bag () print () test_simple_stock_cutting () print () test_stock_cutting_2 () Optimal value found Optimal items found Optimal value found Optimal items found test passed total doffs: 96 5, Counter({6: 2}) 50, Counter({7: 2}) 41, Counter({4: 2, 6: 1}) test passed total doffs: 59 39, Counter({172: 20, 160: 3, 236: 1}) 16, Counter({236: 12, 172: 4, 160: 4}) 4, Counter({172: 15, 236: 6, 160: 1}) 2: When we need to limit the number of patterns in the layouts \u00b6 let's suppose we want a solution that only has 2 patterns in any given layout. When using the column generation method we used seed_patterns to create the naive layouts: q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 ans = 96 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) patterns [[Counter({4: 3}), 3], [Counter({6: 2}), 3], [Counter({7: 2}), 1]] Now, however, we'd like to include layouts that are combinations of each width. Let's start with just 2 layouts per pattern: q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 ans = 96 patterns = seed_patterns ( widths , W , max_unique_layouts = 2 ) patterns [[Counter({4: 3}), 3], [Counter({6: 2}), 3], [Counter({7: 2}), 1], [Counter({4: 2, 6: 1}), 1], [Counter({4: 2, 7: 1}), 0]] The trailing numbers after the Counter object tell us the remainder on each pattern. We can now use these in our linear programming optimization step to determine how these layouts can be combined to fullfill the order. Because we are not allowing the knapsack problem to deliver any amount of unique widths in a pattern, we will not be using the column generation method. Instead we send the layouts we've created to the linear programming optimization step and take the best answer we can get: X , val = solveX ( patterns , widths , q ) assert sum ( X ) == ans , \"Optimal doffs not found\" print ( \"test passed\" ) print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) test passed total doffs: 96 5, Counter({6: 2}) 50, Counter({7: 2}) 41, Counter({4: 2, 6: 1}) Incidentally the solution is the same because the column generation method solution did not have any patterns with more than 2 layouts. Let's take another example with the second unit test parameters: widths = [ i + j for i , j in zip ([ 2 , 2 , 2 ], [ 170 , 234 , 158 ])] q = [ 879 , 244 , 181 ] W = 4160 ans = 59 patterns = seed_patterns ( widths , W , max_unique_layouts = 2 ) display ( patterns ) print () X , val = solveX ( patterns , widths , q ) assert sum ( X ) <= ans , \"Optimal doffs not found\" print ( \"test passed\" ) print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) [[Counter({172: 24}), 32], [Counter({236: 17}), 148], [Counter({160: 26}), 0], [Counter({172: 20, 236: 3}), 12]] test passed total doffs: 58 7, Counter({236: 17}) 7, Counter({160: 26}) 44, Counter({172: 20, 236: 3}) In this case, we actually get an answer that is better than the column generation method! 3: When we need to limit the number of layouts in a solution \u00b6 When we need to limit the total number of layouts in a solution, we will have to make multiple calls to the linear programming step and compare the results of each call. Let's say we are not limited by the number of layouts per pattern. We would then want to send all permutations of the following to the linear programming step: widths = [ i + j for i , j in zip ([ 2 , 2 , 2 ], [ 170 , 234 , 158 ])] q = [ 879 , 244 , 181 ] W = 4160 ans = 59 patterns = seed_patterns ( widths , W , max_unique_layouts = 3 ) display ( patterns ) [[Counter({172: 24}), 32], [Counter({236: 17}), 148], [Counter({160: 26}), 0], [Counter({172: 20, 236: 3}), 12], [Counter({172: 4, 236: 12, 160: 4}), 0]] max_patterns = 2 # current_max will account for all max_patterns and anything less for current_max in range ( 1 , max_patterns + 1 ): # our pre_sacks contains the collection of combinations pre_sacks = list ( combinations ( patterns , current_max )) # the sack is what we will send to the lin prog program # we will borrow from column_gen to supplement any pattern # combinations that could use an extra layout (to get to # the max_patterns value) for sack in pre_sacks : print ( sack ) print () ([Counter({172: 24}), 32],) ([Counter({236: 17}), 148],) ([Counter({160: 26}), 0],) ([Counter({172: 20, 236: 3}), 12],) ([Counter({236: 12, 172: 4, 160: 4}), 0],) ([Counter({172: 24}), 32], [Counter({236: 17}), 148]) ([Counter({172: 24}), 32], [Counter({160: 26}), 0]) ([Counter({172: 24}), 32], [Counter({172: 20, 236: 3}), 12]) ([Counter({172: 24}), 32], [Counter({236: 12, 172: 4, 160: 4}), 0]) ([Counter({236: 17}), 148], [Counter({160: 26}), 0]) ([Counter({236: 17}), 148], [Counter({172: 20, 236: 3}), 12]) ([Counter({236: 17}), 148], [Counter({236: 12, 172: 4, 160: 4}), 0]) ([Counter({160: 26}), 0], [Counter({172: 20, 236: 3}), 12]) ([Counter({160: 26}), 0], [Counter({236: 12, 172: 4, 160: 4}), 0]) ([Counter({172: 20, 236: 3}), 12], [Counter({236: 12, 172: 4, 160: 4}), 0]) Taking those combinations into effect now: max_patterns = 2 # current_max will account for all max_patterns and anything less for current_max in range ( 1 , max_patterns + 1 ): # our pre_sacks contains the collection of combinations pre_sacks = list ( combinations ( patterns , current_max )) # the sack is what we will send to the lin prog program # we will borrow from column_gen to supplement any pattern # combinations that could use an extra layout (to get to # the max_patterns value) for sack in pre_sacks : sack = list ( sack ) while True : X , val = solveX ( sack , widths , q ) pattern , total = pack_knap ( widths , val , W ) if ( total > 1 ) and ( len ( sack ) < max_patterns ): sack . append ([ pattern , 0 ]) continue break if sum ( X ) > 0 : # print(total) # print(len(sack)) print ( f \"total doffs: { sum ( X ) } \" ) for quant , pattern in zip ( X , sack ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) print () total doffs: 263 82, Counter({172: 20, 236: 3}) 181, Counter({160: 1}) total doffs: 76 46, Counter({236: 12, 172: 4, 160: 4}) 30, Counter({172: 24}) total doffs: 76 30, Counter({172: 24}) 46, Counter({236: 12, 172: 4, 160: 4}) total doffs: 220 220, Counter({236: 12, 172: 4, 160: 4}) total doffs: 89 7, Counter({160: 26}) 82, Counter({172: 20, 236: 3}) total doffs: 220 220, Counter({236: 12, 172: 4, 160: 4}) total doffs: 81 35, Counter({172: 20, 236: 3}) 46, Counter({236: 12, 172: 4, 160: 4}) 4: When we need a single layout \u00b6 Sometimes, we may want to fullfill our order in a single layout. This problem is actually not as difficult to solve as the others, as the restriction to a single layout forces us to appropriate cuts such that the quantities ordered of each width are accurately reflected. In other words, if we want 1 width of 2, 2 widths of 3, and 1 width of 4 then our layout should as best as possible reflect a ratio of 1:2:1 between our products 2, 3, and 4. Let's code this up. widths = [ 170 , 234 , 158 ] n = [ 2 , 2 , 2 ] w = [ i + j for i , j in zip ( widths , n )] q = [ 879 , 244 , 181 ] W = 4160 ans = 59 # we will want there to be at least 1 cut of each width, i.e. max(1, calc) # calc: proportion_of_item_in_orders * quantity_of_item_that_can_fit_in_usable_width layout = [ max ( 1 , math . floor ( i / sum ( q ) * W / j )) for i , j in zip ( q , w )] display ( layout ) [16, 3, 3] after we create this initial layout we will have to check that we did not go over the usable width, W , and if so remove any items that are closest or above their ratio in the order quantites, q [ math . remainder ( i / sum ( q ) * W / j , 1 ) for i , j in zip ( q , w ) ] [0.3033242973320043, 0.2983258812519498, -0.39110429447852724] math.remainder(x, y) will return the remainder of x - yn where yn is the closest integer to x. We can use this to determine which order quantities were rounded down the most from their ideal value. # since we took the floor in the calculation for layout, the remainder # will tell us how much abov remainder = [ math . remainder ( i / sum ( q ) * W / j , 1 ) if ( math . remainder ( i / sum ( q ) * W / j , 1 ) < 0 ) else - 1 for i , j in zip ( q , w ) ] display ( remainder ) order = np . argsort ( remainder ) display ( order ) [-1, -1, -0.39110429447852724] array([0, 1, 2]) def make_best_pattern ( q , w , n , usable_width = 4160 , verbiose = True ): \"\"\" Creates the best possible pattern such that all orders are fullfilled in a single layout Parameters ---------- q: list rolls required (in jumbo lengths) w: list widths required n: list neckins for widths usable_width: int jumbo/doff usable width Returns ------- layout: list cuts for jumbo for each width (no width is excluded) \"\"\" # if not all slits can fit in a single bin, do not return a single optimum layout if np . sum ([ n , w ]) > usable_width : return None layout = [ max ( 1 , math . floor ( i / sum ( q ) * usable_width / j )) for i , j in zip ( q , w )] # give priority to widths that had to round down the most # when filling up the rest of the pattern remainder = [ math . remainder ( i / sum ( q ) * usable_width / j , 1 ) if ( math . remainder ( i / sum ( q ) * usable_width / j , 1 ) < 0 ) else - 1 for i , j in zip ( q , w ) ] order = np . argsort ( remainder ) # sometimes the floor still puts us over while usable_width - sum ([ i * j for i , j in zip ( layout , w )]) < 0 : layout [ np . argmax ( layout )] -= 1 while ( usable_width - sum ([ i * j for i , j in zip ( layout , w )])) > min ( w ): for i in order [:: - 1 ]: layout [ i ] += 1 if usable_width - sum ([ i * j for i , j in zip ( layout , w )]) < 0 : layout [ i ] -= 1 # compute the loss for the final layout layout_loss = usable_width - sum ([ i * j for i , j in zip ( layout , w )]) if verbiose : print ( \"layout pattern: {} \" . format ( dict ( zip ([ i - j for i , j in zip ( w , n )], layout )))) print ( \"pattern loss: {:0.2f} %\" . format ( layout_loss / usable_width * 100 )) # sometimes all orders can't be fullfilled in a single layout if any ([ i == 0 for i in layout ]): return layout else : # multiply to get the minimum doffs required # layout * doffs > q doffs = max ([ math . ceil ( i / j ) for i , j in zip ( q , layout )]) if verbiose : print ( \"minimum doffs to fill order: {} \" . format ( doffs )) # what inventory is created inventory = dict ( zip ([ i - j for i , j in zip ( w , n )],[ i * doffs - j for i , j in zip ( layout , q )])) if verbiose : print ( \"inventory created: {} \" . format ( inventory )) return layout widths = [ 170 , 234 , 158 ] n = [ 2 , 2 , 2 ] q = [ 879 , 244 , 181 ] W = 4160 ans = 59 import math make_best_pattern ( q , widths , n , usable_width = W , verbiose = True ) layout pattern: {168: 16, 232: 3, 156: 4} pattern loss: 2.55 % minimum doffs to fill order: 82 inventory created: {168: 433, 232: 2, 156: 147} [16, 3, 4]","title":"Edge Cases"},{"location":"solutions/SOLN_P5_Stock_Cutting/#stock-cutting-part-5-edge-cases","text":"In this project notebook we'll be exploring edge cases. Specifically, how do we use the building blocks we've created so far to account for user restrictions on layouts and patterns.","title":"Stock Cutting Part 5: Edge Cases"},{"location":"solutions/SOLN_P5_Stock_Cutting/#1-import-functions-and-libraries","text":"from collections import Counter from itertools import combinations from scipy.optimize import linprog from math import ceil import numpy as np def solveX ( patterns , widths , q ): \"\"\" solves the linprog (minimum doffs needed given set of patterns) as well as the dual problem \"\"\" lhs_ineq = [] for pattern in patterns : # inset will be our full build of a given \"pattern\" inset = [] for width in widths : # try to access the slitwidth counts, otherwise # it means none of that slitwidth was included try : inset . append ( - pattern [ 0 ][ width ]) except : inset . append ( 0 ) # add inset to the set of equations (patterns) lhs_ineq . append ( inset ) lhs_ineq = np . array ( lhs_ineq ) . T . tolist () # rhs is the min orders we need for each slitwidth rhs_ineq = [ - i for i in q ] # min x1 + x2 + .... Xn obj = np . ones ( len ( lhs_ineq [ 0 ])) # linprog will determine the minimum number we need # of each pattern result = linprog ( c = obj , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) X = [ ceil ( i ) for i in result [ 'x' ]] dual_problem = linprog ( c = rhs_ineq , A_ub =- np . array ( lhs_ineq ) . T , b_ub = obj , method = \"revised simplex\" ) val = [ i for i in dual_problem [ 'x' ]] return X , val def pack_knap ( wt , val , W ): new_wt = [] new_val = [] for w , v in zip ( wt , val ): new_wt += [ w ] * int ( W / w ) new_val += [ v ] * int ( W / w ) wt = new_wt val = new_val t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) loss = W - best sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ wt [ i ] for i in list ( sack )]) value = Counter ([ val [ i ] for i in list ( sack )]) total = 0 for worth , multiple in value . items (): total += worth * multiple return pattern , total def seed_patterns ( _widths , W , max_unique_layouts = 3 ): patterns = [] for current_max in range ( 1 , max_unique_layouts + 1 ): pre_sacks = list ( combinations ( _widths , current_max )) for widths in pre_sacks : new = [] for w in widths : new += [ w ] * int ( W / w ) widths = new t = initt ( W , widths ) best = knapsack ( widths , widths , W , len ( widths ), t ) loss = W - best sack = reconstruct ( len ( widths ), W , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) if [ pattern , loss ] not in patterns : patterns . append ([ pattern , loss ]) return patterns def initt ( W , val ): return [[ None for i in range ( W + 1 )] for j in range ( len ( val ) + 1 )] def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != None : return t [ n ][ w ] # now include the conditionals if wt [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( wt , val , w , n - 1 , t ), knapsack ( wt , val , w - wt [ n - 1 ], n - 1 , t ) + val [ n - 1 ]) return t [ n ][ w ] elif wt [ n - 1 ] > w : t [ n ][ w ] = knapsack ( wt , val , w , n - 1 , t ) return t [ n ][ w ] def reconstruct ( N , W , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if ( t [ j + 1 ][ W ] not in t [ j ]) and ( t [ j + 1 ][ W ] != 0 ): recon . add ( j ) W = W - wt [ j ] # move columns in table lookup if W < 0 : break else : continue return recon def test_small_bag (): # the problem parameters val = [ 60 , 50 , 70 , 30 ] wt = [ 5 , 3 , 4 , 2 ] W = 5 # the known solution max_val = 80 max_items = [ 50 , 30 ] t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert list ( pattern . keys ()) == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_val_weight_equality (): # the problem parameters val = wt = [ 2 , 2 , 2 , 2 , 5 , 5 , 5 , 5 ] W = 14 # the known solution max_val = 14 max_items = Counter ([ 5 , 5 , 2 , 2 ]) t = initt ( W , val ) best = knapsack ( wt , val , W , len ( val ), t ) sack = reconstruct ( len ( val ), W , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert pattern == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_simple_stock_cutting (): q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 ans = 96 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) while True : X , val = solveX ( patterns , widths , q ) pattern , total = pack_knap ( w , val , W ) if total > 1 : patterns . append ([ pattern , 0 ]) continue break assert sum ( X ) == ans , \"Optimal doffs not found\" print ( \"test passed\" ) print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) def test_stock_cutting_2 (): widths = [ i + j for i , j in zip ([ 2 , 2 , 2 ], [ 170 , 234 , 158 ])] q = [ 879 , 244 , 181 ] W = 4160 ans = 59 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) while True : X , val = solveX ( patterns , widths , q ) pattern , total = pack_knap ( widths , val , W ) if total > 1 : patterns . append ([ pattern , 0 ]) continue break assert sum ( X ) == ans , \"Optimal doffs not found\" print ( \"test passed\" ) print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) run tests test_val_weight_equality () print () test_small_bag () print () test_simple_stock_cutting () print () test_stock_cutting_2 () Optimal value found Optimal items found Optimal value found Optimal items found test passed total doffs: 96 5, Counter({6: 2}) 50, Counter({7: 2}) 41, Counter({4: 2, 6: 1}) test passed total doffs: 59 39, Counter({172: 20, 160: 3, 236: 1}) 16, Counter({236: 12, 172: 4, 160: 4}) 4, Counter({172: 15, 236: 6, 160: 1})","title":"1: Import Functions and Libraries"},{"location":"solutions/SOLN_P5_Stock_Cutting/#2-when-we-need-to-limit-the-number-of-patterns-in-the-layouts","text":"let's suppose we want a solution that only has 2 patterns in any given layout. When using the column generation method we used seed_patterns to create the naive layouts: q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 ans = 96 patterns = seed_patterns ( widths , W , max_unique_layouts = 1 ) patterns [[Counter({4: 3}), 3], [Counter({6: 2}), 3], [Counter({7: 2}), 1]] Now, however, we'd like to include layouts that are combinations of each width. Let's start with just 2 layouts per pattern: q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] W = 15 ans = 96 patterns = seed_patterns ( widths , W , max_unique_layouts = 2 ) patterns [[Counter({4: 3}), 3], [Counter({6: 2}), 3], [Counter({7: 2}), 1], [Counter({4: 2, 6: 1}), 1], [Counter({4: 2, 7: 1}), 0]] The trailing numbers after the Counter object tell us the remainder on each pattern. We can now use these in our linear programming optimization step to determine how these layouts can be combined to fullfill the order. Because we are not allowing the knapsack problem to deliver any amount of unique widths in a pattern, we will not be using the column generation method. Instead we send the layouts we've created to the linear programming optimization step and take the best answer we can get: X , val = solveX ( patterns , widths , q ) assert sum ( X ) == ans , \"Optimal doffs not found\" print ( \"test passed\" ) print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) test passed total doffs: 96 5, Counter({6: 2}) 50, Counter({7: 2}) 41, Counter({4: 2, 6: 1}) Incidentally the solution is the same because the column generation method solution did not have any patterns with more than 2 layouts. Let's take another example with the second unit test parameters: widths = [ i + j for i , j in zip ([ 2 , 2 , 2 ], [ 170 , 234 , 158 ])] q = [ 879 , 244 , 181 ] W = 4160 ans = 59 patterns = seed_patterns ( widths , W , max_unique_layouts = 2 ) display ( patterns ) print () X , val = solveX ( patterns , widths , q ) assert sum ( X ) <= ans , \"Optimal doffs not found\" print ( \"test passed\" ) print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) [[Counter({172: 24}), 32], [Counter({236: 17}), 148], [Counter({160: 26}), 0], [Counter({172: 20, 236: 3}), 12]] test passed total doffs: 58 7, Counter({236: 17}) 7, Counter({160: 26}) 44, Counter({172: 20, 236: 3}) In this case, we actually get an answer that is better than the column generation method!","title":"2: When we need to limit the number of patterns in the layouts"},{"location":"solutions/SOLN_P5_Stock_Cutting/#3-when-we-need-to-limit-the-number-of-layouts-in-a-solution","text":"When we need to limit the total number of layouts in a solution, we will have to make multiple calls to the linear programming step and compare the results of each call. Let's say we are not limited by the number of layouts per pattern. We would then want to send all permutations of the following to the linear programming step: widths = [ i + j for i , j in zip ([ 2 , 2 , 2 ], [ 170 , 234 , 158 ])] q = [ 879 , 244 , 181 ] W = 4160 ans = 59 patterns = seed_patterns ( widths , W , max_unique_layouts = 3 ) display ( patterns ) [[Counter({172: 24}), 32], [Counter({236: 17}), 148], [Counter({160: 26}), 0], [Counter({172: 20, 236: 3}), 12], [Counter({172: 4, 236: 12, 160: 4}), 0]] max_patterns = 2 # current_max will account for all max_patterns and anything less for current_max in range ( 1 , max_patterns + 1 ): # our pre_sacks contains the collection of combinations pre_sacks = list ( combinations ( patterns , current_max )) # the sack is what we will send to the lin prog program # we will borrow from column_gen to supplement any pattern # combinations that could use an extra layout (to get to # the max_patterns value) for sack in pre_sacks : print ( sack ) print () ([Counter({172: 24}), 32],) ([Counter({236: 17}), 148],) ([Counter({160: 26}), 0],) ([Counter({172: 20, 236: 3}), 12],) ([Counter({236: 12, 172: 4, 160: 4}), 0],) ([Counter({172: 24}), 32], [Counter({236: 17}), 148]) ([Counter({172: 24}), 32], [Counter({160: 26}), 0]) ([Counter({172: 24}), 32], [Counter({172: 20, 236: 3}), 12]) ([Counter({172: 24}), 32], [Counter({236: 12, 172: 4, 160: 4}), 0]) ([Counter({236: 17}), 148], [Counter({160: 26}), 0]) ([Counter({236: 17}), 148], [Counter({172: 20, 236: 3}), 12]) ([Counter({236: 17}), 148], [Counter({236: 12, 172: 4, 160: 4}), 0]) ([Counter({160: 26}), 0], [Counter({172: 20, 236: 3}), 12]) ([Counter({160: 26}), 0], [Counter({236: 12, 172: 4, 160: 4}), 0]) ([Counter({172: 20, 236: 3}), 12], [Counter({236: 12, 172: 4, 160: 4}), 0]) Taking those combinations into effect now: max_patterns = 2 # current_max will account for all max_patterns and anything less for current_max in range ( 1 , max_patterns + 1 ): # our pre_sacks contains the collection of combinations pre_sacks = list ( combinations ( patterns , current_max )) # the sack is what we will send to the lin prog program # we will borrow from column_gen to supplement any pattern # combinations that could use an extra layout (to get to # the max_patterns value) for sack in pre_sacks : sack = list ( sack ) while True : X , val = solveX ( sack , widths , q ) pattern , total = pack_knap ( widths , val , W ) if ( total > 1 ) and ( len ( sack ) < max_patterns ): sack . append ([ pattern , 0 ]) continue break if sum ( X ) > 0 : # print(total) # print(len(sack)) print ( f \"total doffs: { sum ( X ) } \" ) for quant , pattern in zip ( X , sack ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) print () total doffs: 263 82, Counter({172: 20, 236: 3}) 181, Counter({160: 1}) total doffs: 76 46, Counter({236: 12, 172: 4, 160: 4}) 30, Counter({172: 24}) total doffs: 76 30, Counter({172: 24}) 46, Counter({236: 12, 172: 4, 160: 4}) total doffs: 220 220, Counter({236: 12, 172: 4, 160: 4}) total doffs: 89 7, Counter({160: 26}) 82, Counter({172: 20, 236: 3}) total doffs: 220 220, Counter({236: 12, 172: 4, 160: 4}) total doffs: 81 35, Counter({172: 20, 236: 3}) 46, Counter({236: 12, 172: 4, 160: 4})","title":"3: When we need to limit the number of layouts in a solution"},{"location":"solutions/SOLN_P5_Stock_Cutting/#4-when-we-need-a-single-layout","text":"Sometimes, we may want to fullfill our order in a single layout. This problem is actually not as difficult to solve as the others, as the restriction to a single layout forces us to appropriate cuts such that the quantities ordered of each width are accurately reflected. In other words, if we want 1 width of 2, 2 widths of 3, and 1 width of 4 then our layout should as best as possible reflect a ratio of 1:2:1 between our products 2, 3, and 4. Let's code this up. widths = [ 170 , 234 , 158 ] n = [ 2 , 2 , 2 ] w = [ i + j for i , j in zip ( widths , n )] q = [ 879 , 244 , 181 ] W = 4160 ans = 59 # we will want there to be at least 1 cut of each width, i.e. max(1, calc) # calc: proportion_of_item_in_orders * quantity_of_item_that_can_fit_in_usable_width layout = [ max ( 1 , math . floor ( i / sum ( q ) * W / j )) for i , j in zip ( q , w )] display ( layout ) [16, 3, 3] after we create this initial layout we will have to check that we did not go over the usable width, W , and if so remove any items that are closest or above their ratio in the order quantites, q [ math . remainder ( i / sum ( q ) * W / j , 1 ) for i , j in zip ( q , w ) ] [0.3033242973320043, 0.2983258812519498, -0.39110429447852724] math.remainder(x, y) will return the remainder of x - yn where yn is the closest integer to x. We can use this to determine which order quantities were rounded down the most from their ideal value. # since we took the floor in the calculation for layout, the remainder # will tell us how much abov remainder = [ math . remainder ( i / sum ( q ) * W / j , 1 ) if ( math . remainder ( i / sum ( q ) * W / j , 1 ) < 0 ) else - 1 for i , j in zip ( q , w ) ] display ( remainder ) order = np . argsort ( remainder ) display ( order ) [-1, -1, -0.39110429447852724] array([0, 1, 2]) def make_best_pattern ( q , w , n , usable_width = 4160 , verbiose = True ): \"\"\" Creates the best possible pattern such that all orders are fullfilled in a single layout Parameters ---------- q: list rolls required (in jumbo lengths) w: list widths required n: list neckins for widths usable_width: int jumbo/doff usable width Returns ------- layout: list cuts for jumbo for each width (no width is excluded) \"\"\" # if not all slits can fit in a single bin, do not return a single optimum layout if np . sum ([ n , w ]) > usable_width : return None layout = [ max ( 1 , math . floor ( i / sum ( q ) * usable_width / j )) for i , j in zip ( q , w )] # give priority to widths that had to round down the most # when filling up the rest of the pattern remainder = [ math . remainder ( i / sum ( q ) * usable_width / j , 1 ) if ( math . remainder ( i / sum ( q ) * usable_width / j , 1 ) < 0 ) else - 1 for i , j in zip ( q , w ) ] order = np . argsort ( remainder ) # sometimes the floor still puts us over while usable_width - sum ([ i * j for i , j in zip ( layout , w )]) < 0 : layout [ np . argmax ( layout )] -= 1 while ( usable_width - sum ([ i * j for i , j in zip ( layout , w )])) > min ( w ): for i in order [:: - 1 ]: layout [ i ] += 1 if usable_width - sum ([ i * j for i , j in zip ( layout , w )]) < 0 : layout [ i ] -= 1 # compute the loss for the final layout layout_loss = usable_width - sum ([ i * j for i , j in zip ( layout , w )]) if verbiose : print ( \"layout pattern: {} \" . format ( dict ( zip ([ i - j for i , j in zip ( w , n )], layout )))) print ( \"pattern loss: {:0.2f} %\" . format ( layout_loss / usable_width * 100 )) # sometimes all orders can't be fullfilled in a single layout if any ([ i == 0 for i in layout ]): return layout else : # multiply to get the minimum doffs required # layout * doffs > q doffs = max ([ math . ceil ( i / j ) for i , j in zip ( q , layout )]) if verbiose : print ( \"minimum doffs to fill order: {} \" . format ( doffs )) # what inventory is created inventory = dict ( zip ([ i - j for i , j in zip ( w , n )],[ i * doffs - j for i , j in zip ( layout , q )])) if verbiose : print ( \"inventory created: {} \" . format ( inventory )) return layout widths = [ 170 , 234 , 158 ] n = [ 2 , 2 , 2 ] q = [ 879 , 244 , 181 ] W = 4160 ans = 59 import math make_best_pattern ( q , widths , n , usable_width = W , verbiose = True ) layout pattern: {168: 16, 232: 3, 156: 4} pattern loss: 2.55 % minimum doffs to fill order: 82 inventory created: {168: 433, 232: 2, 156: 147} [16, 3, 4]","title":"4: When we need a single layout"},{"location":"solutions/SOLN_P6_Stock_Cutting/","text":"Stock Cutting Part 6: API \u00b6 In this project notebook we'll be showcasing how the API connects to the deka logic Import Functions and Libraries \u00b6 Note: in this notebook I have switched the variable W to B , this represents the width of the mother roll from collections import Counter from itertools import combinations from scipy.optimize import linprog from math import ceil import numpy as np def solveX ( patterns , widths , q ): \"\"\" solves the linprog (minimum doffs needed given set of patterns) as well as the dual problem \"\"\" lhs_ineq = [] for pattern in patterns : # inset will be our full build of a given \"pattern\" inset = [] for width in widths : # try to access the slitwidth counts, otherwise # it means none of that slitwidth was included try : inset . append ( - pattern [ 0 ][ width ]) except : inset . append ( 0 ) # add inset to the set of equations (patterns) lhs_ineq . append ( inset ) lhs_ineq = np . array ( lhs_ineq ) . T . tolist () # rhs is the min orders we need for each slitwidth rhs_ineq = [ - i for i in q ] # min x1 + x2 + .... Xn obj = np . ones ( len ( lhs_ineq [ 0 ])) # linprog will determine the minimum number we need # of each pattern result = linprog ( c = obj , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) X = [ ceil ( i ) for i in result [ 'x' ]] dual_problem = linprog ( c = rhs_ineq , A_ub =- np . array ( lhs_ineq ) . T , b_ub = obj , method = \"revised simplex\" ) val = [ i for i in dual_problem [ 'x' ]] return X , val def pack_knap ( wt , val , B ): new_wt = [] new_val = [] for w , v in zip ( wt , val ): new_wt += [ w ] * int ( B / w ) new_val += [ v ] * int ( B / w ) wt = new_wt val = new_val t = initt ( B , val ) best = knapsack ( wt , val , B , len ( val ), t ) loss = B - best sack = reconstruct ( len ( val ), B , t , wt ) pattern = Counter ([ wt [ i ] for i in list ( sack )]) value = Counter ([ val [ i ] for i in list ( sack )]) total = 0 for worth , multiple in value . items (): total += worth * multiple return pattern , total def seed_patterns ( _widths , B , max_widths = 3 ): patterns = [] for current_max in range ( 1 , max_widths + 1 ): pre_sacks = list ( combinations ( _widths , current_max )) for widths in pre_sacks : new = [] for w in widths : new += [ w ] * int ( B / w ) widths = new t = initt ( B , widths ) best = knapsack ( widths , widths , B , len ( widths ), t ) loss = B - best sack = reconstruct ( len ( widths ), B , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) if [ pattern , loss ] not in patterns : patterns . append ([ pattern , loss ]) return patterns def initt ( B , val ): return [[ None for i in range ( B + 1 )] for j in range ( len ( val ) + 1 )] def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != None : return t [ n ][ w ] # now include the conditionals if wt [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( wt , val , w , n - 1 , t ), knapsack ( wt , val , w - wt [ n - 1 ], n - 1 , t ) + val [ n - 1 ]) return t [ n ][ w ] elif wt [ n - 1 ] > w : t [ n ][ w ] = knapsack ( wt , val , w , n - 1 , t ) return t [ n ][ w ] def reconstruct ( N , B , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if ( t [ j + 1 ][ B ] not in t [ j ]) and ( t [ j + 1 ][ B ] != 0 ): recon . add ( j ) B = B - wt [ j ] # move columns in table lookup if B < 0 : break else : continue return recon def test_small_bag (): # the problem parameters val = [ 60 , 50 , 70 , 30 ] wt = [ 5 , 3 , 4 , 2 ] B = 5 # the known solution max_val = 80 max_items = [ 50 , 30 ] t = initt ( B , val ) best = knapsack ( wt , val , B , len ( val ), t ) sack = reconstruct ( len ( val ), B , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert list ( pattern . keys ()) == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_val_weight_equality (): # the problem parameters val = wt = [ 2 , 2 , 2 , 2 , 5 , 5 , 5 , 5 ] B = 14 # the known solution max_val = 14 max_items = Counter ([ 5 , 5 , 2 , 2 ]) t = initt ( B , val ) best = knapsack ( wt , val , B , len ( val ), t ) sack = reconstruct ( len ( val ), B , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert pattern == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_simple_stock_cutting (): q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] B = 15 ans = 96 patterns = seed_patterns ( widths , B , max_widths = 1 ) while True : X , val = solveX ( patterns , widths , q ) pattern , total = pack_knap ( w , val , B ) if total > 1 : patterns . append ([ pattern , 0 ]) continue break assert sum ( X ) == ans , \"Optimal doffs not found\" print ( \"test passed\" ) print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) def test_stock_cutting_2 (): widths = [ i + j for i , j in zip ([ 2 , 2 , 2 ], [ 170 , 234 , 158 ])] q = [ 879 , 244 , 181 ] B = 4160 ans = 59 patterns = seed_patterns ( widths , B , max_widths = 1 ) while True : X , val = solveX ( patterns , widths , q ) pattern , total = pack_knap ( widths , val , B ) if total > 1 : patterns . append ([ pattern , 0 ]) continue break assert sum ( X ) == ans , \"Optimal doffs not found\" print ( \"test passed\" ) print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) run tests test_val_weight_equality () print () test_small_bag () print () test_simple_stock_cutting () print () test_stock_cutting_2 () Optimal value found Optimal items found Optimal value found Optimal items found test passed total doffs: 96 5, Counter({6: 2}) 50, Counter({7: 2}) 41, Counter({4: 2, 6: 1}) test passed total doffs: 59 39, Counter({172: 20, 160: 3, 236: 1}) 16, Counter({236: 12, 172: 4, 160: 4}) 4, Counter({172: 15, 236: 6, 160: 1}) Defining Objects \u00b6 # from test_stock_cutting_2 w = [ 170 , 234 , 158 ] n = [ 2 , 2 , 2 ] widths = [ i + j for i , j in zip ( n , w )] q = [ 879 , 244 , 181 ] B = 4160 ans = 59 # a new variable that we have not yet defined will be the length of the mother rolls L = 17000 # we will pass our deckle data around in an object called a bucket bucket = dict () bucket [ 'w' ] = w bucket [ 'n' ] = n bucket [ 'L' ] = L bucket [ 'q' ] = q bucket [ 'B' ] = B display ( bucket ) {'w': [170, 234, 158], 'n': [2, 2, 2], 'L': 17000, 'q': [879, 244, 181], 'B': 4160} In addition to defining a bucket object, we will also formalize the hyperparameters for our deckle algorithm Primary: bucket : dict, the collection of deckle data w : list of ints, slit widths n : list of ints, knife in loss L : int, length of the mother roll q : list of ints, quantities ordered of each slit width B : int, the width of the mother roll max_widths : int, the maximum number of unique widths we want on any specific layout max_layouts : int, the maximum number of unique layouts we want to fullfill the deckle solution def deckle ( bucket , max_widths = 3 , max_layouts = 3 ): w = bucket [ 'w' ] n = bucket [ 'n' ] L = bucket [ 'L' ] q = bucket [ 'q' ] B = bucket [ 'B' ] widths = [ i + j for i , j in zip ( n , w )] solutions = [] # make the patterns first (pre_sacks) # current_max will account for all max_layouts and anything less for current_max in range ( 1 , max_layouts + 1 ): # our pre_sacks contains the collection of combinations pre_sacks = list ( combinations ( patterns , current_max )) # the sack is what we will send to the lin prog program # we will borrow from column_gen to supplement any pattern # combinations that could use an extra layout (to get to # the max_layouts value) # for sack in pre_sacks: # print(sack) # print() # current_max will account for all max_layouts and anything less for current_max in range ( 1 , max_layouts + 1 ): # our pre_sacks contains the collection of combinations pre_sacks = list ( combinations ( patterns , current_max )) # the sack is what we will send to the lin prog program # we will borrow from column_gen to supplement any pattern # combinations that could use an extra layout (to get to # the max_layouts value) for sack in pre_sacks : sack = list ( sack ) while True : X , val = solveX ( sack , widths , q ) pattern , total = pack_knap ( widths , val , B ) if ( total > 1 ) and ( len ( sack ) < max_layouts ): sack . append ([ pattern , 0 ]) continue break if sum ( X ) > 0 : # print(total) # print(len(sack)) # print(f\"total doffs: {sum(X)}\") for quant , pattern in zip ( X , sack ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) print () solutions . append ([ X , sack ]) return solutions Parallel Processing \u00b6 For our parallel processing wrapper we introduce a couple more hyperparameters that will allow us to seach through a broader optimization space Secondary: production_targets : list of floats, default [1] . Fraction of each quantity in q to be passed to optimization task edge_trim_allowance : list of ints, default [0] . The amount of edge trim (mm) to add to each end of the mother roll. import math import multiprocessing as mp def make_search ( bucket , max_widths , max_layouts , production_targets = [ 1 ], edge_trim_allowance = [ 0 ], verbose = False ): \"\"\" Handles the parallel search for both schedule_api and front_search_api \"\"\" params = [] goals = [ 1 , 3 , 10 , 100 , 1000 ] # min_patterns will tell us if we can fit all widths into a single mother roll or not min_patterns = math . ceil ( sum ( bucket [ 'w' ]) / bucket [ 'B' ]) # we will mix n match every possible deckle request that comes from the hyperparameters # i.e. max 1 width/layout + max 3 layouts + 99% production + 10mm edge allowance for current_max_width in range ( max_widths + 1 ): for current_max_layout in range ( min_patterns , max_layouts + 1 ): for target in production_targets : for edge in edge_trim_allowance : # only keep combinations that are possible to solve ie the product # of max_layouts and max_widths needs to be greater than the number # of unique widths (bucket['w']) for recursion_goal in goals [: goal ]: if current_max_width * current_max_layout >= len ( bucket [ 'w' ]): # the params list will be used by multiprocessing library to find # each request params . append ([ bucket , current_max_width , current_max_layout , target , edge , recursion_goal , verbiose , opt ]) return params params = make_search ( bucket , 3 , 3 ) len ( params ) 18 We now want to solve the deckle problem 18 times pool = mp . Pool ( mp . cpu_count ()) results = [ pool . apply_async ( deckle , args = ( param [ 0 ], param [ 1 ], param [ 2 ], param [ 3 ], param [ 4 ], param [ 5 ], param [ 6 ], param [ 7 ])) for param in params ] pool . close () while True : if all ([ i . ready () for i in results ]): res = [] for i in results : try : a_result = i . get () . copy () a_result [ 3 ][ 'loss' ] = round ( a_result [ 3 ][ 'loss' ] . astype ( float ), 3 ) res . append ( a_result ) except : pass # search had failed df = pd . DataFrame ( res , columns = [ 'loss' , 'jumbos' , 'inventory' , 'summary' , 'combinations' , 'patterns' , 'target' , 'edge' ]) df [ 'str summ' ] = df [ 'summary' ] . astype ( str ) df = df . sort_values ( 'loss' ) . reset_index ( drop = True ) df = df . drop_duplicates ([ 'str summ' ])[[ 'loss' , 'jumbos' , 'inventory' , 'summary' , 'combinations' , 'patterns' , 'target' , 'edge' ]] . reset_index ( drop = True ) df [ 'loss rank' ] = df [ 'loss' ] . rank ( method = 'first' ) df [ 'jumbo rank' ] = df [ 'jumbos' ] . rank ( method = 'first' ) break df [ 'loss' ] = round ( df [ 'loss' ], 2 ) df = df . sort_values ( 'jumbo rank' ) . reset_index ( drop = True ) What we get from the front end \u00b6 req = { \"width1\" : \"818\" , \"width2\" : \"1638\" , \"width3\" : \"\" , \"width4\" : \"\" , \"width5\" : \"\" , \"width6\" : \"\" , \"roll1\" : \"473\" , \"roll2\" : \"241\" , \"roll3\" : \"\" , \"roll4\" : \"\" , \"roll5\" : \"\" , \"roll6\" : \"\" , \"neck1\" : \"6\" , \"neck2\" : \"8\" , \"neck3\" : \"\" , \"neck4\" : \"\" , \"neck5\" : \"\" , \"neck6\" : \"\" , \"usable_width\" : \"4160\" , \"put_up\" : \"11700\" , \"doffs_per_jumbo\" : \"1\" , \"max_widths\" : \"2\" , \"max_layouts\" : \"2\" , \"production_targets\" : \"1\" , \"min_prod\" : \"0.99\" , \"max_prod\" : \"1\" , \"edge_allowance\" : \"0\" } how are this json used to populate the appropriate fields for the deka function calls; and how are the results formatted and sent back to the front end def standalone ( req ): \"\"\" Translates the request body into inputs for the cutting stock algorithm \"\"\" max_layouts = int ( req [ \"max_layouts\" ]) max_widths = int ( req [ \"max_widths\" ]) min_prod = float ( req [ \"min_prod\" ]) max_prod = float ( req [ \"max_prod\" ]) # search between min and max in 1% increments if min_prod != max_prod : production_targets = list ( np . arange ( min_prod , max_prod , .01 )) else : production_targets = [ min_prod ] # search with additional edge trim in 1mm increments edge_trim_allowance = int ( req [ \"edge_allowance\" ]) edge_trim_allowance = list ( range ( edge_trim_allowance + 1 )) # build the deckle bucket w = [ int ( req [ i ]) for i in req . keys () if ( 'width' in i ) & ( req [ i ] != '' ) & ( '_width' not in i )] q = [ int ( req [ i ]) for i in req . keys () if ( 'roll' in i ) & ( req [ i ] != '' )] q = [ math . ceil ( i / int ( req [ 'doffs_per_jumbo' ])) for i in q ] n = [ int ( req [ i ]) for i in req . keys () if ( 'neck' in i ) & ( req [ i ] != '' )] B = int ( req [ 'usable_width' ]) L = int ( req [ 'put_up' ]) * int ( req [ 'doffs_per_jumbo' ]) w = [ i + j for i , j in zip ( w , n )] bucket = dict () bucket [ 'w' ] = w bucket [ 'n' ] = n bucket [ 'L' ] = L bucket [ 'q' ] = q bucket [ 'B' ] = B def front_search_api ( req , version , suppress_max_inv = 40 ): # rename this to standalone if version == 1 : max_layouts = req [ \"max_layouts\" ] . split ( ', ' ) max_layouts = [ int ( i ) for i in max_layouts ] max_widths = req [ \"max_widths\" ] . split ( ', ' ) max_widths = [ int ( i ) for i in max_widths ] production_targets = req [ \"production_targets\" ] . split ( ', ' ) production_targets = [ float ( i ) for i in production_targets ] edge_trim_allowance = req [ \"edge_allowance\" ] . split ( ', ' ) edge_trim_allowance = [ int ( i ) for i in edge_trim_allowance ] elif version == 2 : max_layouts = int ( req [ \"max_layouts\" ]) max_widths = int ( req [ \"max_widths\" ]) min_prod = float ( req [ \"min_prod\" ]) max_prod = float ( req [ \"max_prod\" ]) if min_prod != max_prod : production_targets = list ( np . arange ( min_prod , max_prod , .01 )) else : production_targets = [ min_prod ] edge_trim_allowance = int ( req [ \"edge_allowance\" ]) edge_trim_allowance = list ( range ( edge_trim_allowance + 1 )) w = [ int ( req [ i ]) for i in req . keys () if ( 'width' in i ) & ( req [ i ] != '' ) & ( '_width' not in i )] q = [ int ( req [ i ]) for i in req . keys () if ( 'roll' in i ) & ( req [ i ] != '' )] q = [ math . ceil ( i / int ( req [ 'doffs_per_jumbo' ])) for i in q ] n = [ int ( req [ i ]) for i in req . keys () if ( 'neck' in i ) & ( req [ i ] != '' )] B = int ( req [ 'usable_width' ]) L = int ( req [ 'put_up' ]) * int ( req [ 'doffs_per_jumbo' ]) w = [ i + j for i , j in zip ( w , n )] bucket = dict () bucket [ 'w' ] = w bucket [ 'n' ] = n bucket [ 'L' ] = L bucket [ 'q' ] = q bucket [ 'B' ] = B df = make_search ( bucket , max_widths , max_layouts , production_targets , edge_trim_allowance , goal = 3 , opt = 'time' , verbiose = False ) # compute string formatted layouts, inventory levels, and whether targets # were met (%) for bucket_ind in range ( df . shape [ 0 ]): tot_q = 0 for index , layout in enumerate ( df . iloc [ bucket_ind ] [ 'summary' ][ 'layout' ]): txt = '' for width in layout : if layout [ width ] != 0 : txt += str ( layout [ width ]) + 'x' + str ( width ) + ' + ' tot_q += layout [ width ] * df . iloc [ bucket_ind ][ 'summary' ][ 'jumbos' ][ index ] txt = txt [: - 3 ] df . loc [ bucket_ind , 'summary' ] . loc [ index , 'layout' ] = txt # print(tot_q) txt = '' tot_inv = 0 for index , layout in enumerate ( df . iloc [ bucket_ind ][ 'inventory' ]): inventory = df . iloc [ bucket_ind ][ 'inventory' ][ layout ] df . loc [ bucket_ind , 'inv. {} ' . format ( layout )] = inventory txt += str ( int ( inventory )) + 'x' + str ( layout ) + ' + ' tot_inv += inventory txt = txt [: - 3 ] target = f \" { tot_q / ( tot_q - tot_inv ) * 100 : .1f } %\" df . loc [ bucket_ind , 'inventory' ] = txt df . loc [ bucket_ind , 'target' ] = target if suppress_max_inv : df = df . loc [( df [[ col for col in df . columns if 'inv.' in col ]] < suppress_max_inv ) . all ( 1 )] dfjson = df . to_json ( orient = \"records\" ) return dfjson","title":"SOLN P6 Stock Cutting"},{"location":"solutions/SOLN_P6_Stock_Cutting/#stock-cutting-part-6-api","text":"In this project notebook we'll be showcasing how the API connects to the deka logic","title":"Stock Cutting Part 6: API"},{"location":"solutions/SOLN_P6_Stock_Cutting/#import-functions-and-libraries","text":"Note: in this notebook I have switched the variable W to B , this represents the width of the mother roll from collections import Counter from itertools import combinations from scipy.optimize import linprog from math import ceil import numpy as np def solveX ( patterns , widths , q ): \"\"\" solves the linprog (minimum doffs needed given set of patterns) as well as the dual problem \"\"\" lhs_ineq = [] for pattern in patterns : # inset will be our full build of a given \"pattern\" inset = [] for width in widths : # try to access the slitwidth counts, otherwise # it means none of that slitwidth was included try : inset . append ( - pattern [ 0 ][ width ]) except : inset . append ( 0 ) # add inset to the set of equations (patterns) lhs_ineq . append ( inset ) lhs_ineq = np . array ( lhs_ineq ) . T . tolist () # rhs is the min orders we need for each slitwidth rhs_ineq = [ - i for i in q ] # min x1 + x2 + .... Xn obj = np . ones ( len ( lhs_ineq [ 0 ])) # linprog will determine the minimum number we need # of each pattern result = linprog ( c = obj , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) X = [ ceil ( i ) for i in result [ 'x' ]] dual_problem = linprog ( c = rhs_ineq , A_ub =- np . array ( lhs_ineq ) . T , b_ub = obj , method = \"revised simplex\" ) val = [ i for i in dual_problem [ 'x' ]] return X , val def pack_knap ( wt , val , B ): new_wt = [] new_val = [] for w , v in zip ( wt , val ): new_wt += [ w ] * int ( B / w ) new_val += [ v ] * int ( B / w ) wt = new_wt val = new_val t = initt ( B , val ) best = knapsack ( wt , val , B , len ( val ), t ) loss = B - best sack = reconstruct ( len ( val ), B , t , wt ) pattern = Counter ([ wt [ i ] for i in list ( sack )]) value = Counter ([ val [ i ] for i in list ( sack )]) total = 0 for worth , multiple in value . items (): total += worth * multiple return pattern , total def seed_patterns ( _widths , B , max_widths = 3 ): patterns = [] for current_max in range ( 1 , max_widths + 1 ): pre_sacks = list ( combinations ( _widths , current_max )) for widths in pre_sacks : new = [] for w in widths : new += [ w ] * int ( B / w ) widths = new t = initt ( B , widths ) best = knapsack ( widths , widths , B , len ( widths ), t ) loss = B - best sack = reconstruct ( len ( widths ), B , t , widths ) pattern = Counter ([ widths [ i ] for i in list ( sack )]) if [ pattern , loss ] not in patterns : patterns . append ([ pattern , loss ]) return patterns def initt ( B , val ): return [[ None for i in range ( B + 1 )] for j in range ( len ( val ) + 1 )] def knapsack ( wt , val , w , n , t ): # n, w will be the row, column of our table # solve the basecase. if w == 0 or n == 0 : return 0 elif t [ n ][ w ] != None : return t [ n ][ w ] # now include the conditionals if wt [ n - 1 ] <= w : t [ n ][ w ] = max ( knapsack ( wt , val , w , n - 1 , t ), knapsack ( wt , val , w - wt [ n - 1 ], n - 1 , t ) + val [ n - 1 ]) return t [ n ][ w ] elif wt [ n - 1 ] > w : t [ n ][ w ] = knapsack ( wt , val , w , n - 1 , t ) return t [ n ][ w ] def reconstruct ( N , B , t , wt ): recon = set () for j in range ( N )[:: - 1 ]: if ( t [ j + 1 ][ B ] not in t [ j ]) and ( t [ j + 1 ][ B ] != 0 ): recon . add ( j ) B = B - wt [ j ] # move columns in table lookup if B < 0 : break else : continue return recon def test_small_bag (): # the problem parameters val = [ 60 , 50 , 70 , 30 ] wt = [ 5 , 3 , 4 , 2 ] B = 5 # the known solution max_val = 80 max_items = [ 50 , 30 ] t = initt ( B , val ) best = knapsack ( wt , val , B , len ( val ), t ) sack = reconstruct ( len ( val ), B , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert list ( pattern . keys ()) == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_val_weight_equality (): # the problem parameters val = wt = [ 2 , 2 , 2 , 2 , 5 , 5 , 5 , 5 ] B = 14 # the known solution max_val = 14 max_items = Counter ([ 5 , 5 , 2 , 2 ]) t = initt ( B , val ) best = knapsack ( wt , val , B , len ( val ), t ) sack = reconstruct ( len ( val ), B , t , wt ) pattern = Counter ([ val [ i ] for i in list ( sack )]) assert best == max_val , \"Optimal value not found\" print ( \"Optimal value found\" ) assert pattern == max_items , \"Optimal items not found\" print ( \"Optimal items found\" ) def test_simple_stock_cutting (): q = [ 80 , 50 , 100 ] widths = w = [ 4 , 6 , 7 ] B = 15 ans = 96 patterns = seed_patterns ( widths , B , max_widths = 1 ) while True : X , val = solveX ( patterns , widths , q ) pattern , total = pack_knap ( w , val , B ) if total > 1 : patterns . append ([ pattern , 0 ]) continue break assert sum ( X ) == ans , \"Optimal doffs not found\" print ( \"test passed\" ) print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) def test_stock_cutting_2 (): widths = [ i + j for i , j in zip ([ 2 , 2 , 2 ], [ 170 , 234 , 158 ])] q = [ 879 , 244 , 181 ] B = 4160 ans = 59 patterns = seed_patterns ( widths , B , max_widths = 1 ) while True : X , val = solveX ( patterns , widths , q ) pattern , total = pack_knap ( widths , val , B ) if total > 1 : patterns . append ([ pattern , 0 ]) continue break assert sum ( X ) == ans , \"Optimal doffs not found\" print ( \"test passed\" ) print ( f \"total doffs: { sum ( X ) } \" , end = \" \\n\\n \" ) for quant , pattern in zip ( X , patterns ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) run tests test_val_weight_equality () print () test_small_bag () print () test_simple_stock_cutting () print () test_stock_cutting_2 () Optimal value found Optimal items found Optimal value found Optimal items found test passed total doffs: 96 5, Counter({6: 2}) 50, Counter({7: 2}) 41, Counter({4: 2, 6: 1}) test passed total doffs: 59 39, Counter({172: 20, 160: 3, 236: 1}) 16, Counter({236: 12, 172: 4, 160: 4}) 4, Counter({172: 15, 236: 6, 160: 1})","title":"Import Functions and Libraries"},{"location":"solutions/SOLN_P6_Stock_Cutting/#defining-objects","text":"# from test_stock_cutting_2 w = [ 170 , 234 , 158 ] n = [ 2 , 2 , 2 ] widths = [ i + j for i , j in zip ( n , w )] q = [ 879 , 244 , 181 ] B = 4160 ans = 59 # a new variable that we have not yet defined will be the length of the mother rolls L = 17000 # we will pass our deckle data around in an object called a bucket bucket = dict () bucket [ 'w' ] = w bucket [ 'n' ] = n bucket [ 'L' ] = L bucket [ 'q' ] = q bucket [ 'B' ] = B display ( bucket ) {'w': [170, 234, 158], 'n': [2, 2, 2], 'L': 17000, 'q': [879, 244, 181], 'B': 4160} In addition to defining a bucket object, we will also formalize the hyperparameters for our deckle algorithm Primary: bucket : dict, the collection of deckle data w : list of ints, slit widths n : list of ints, knife in loss L : int, length of the mother roll q : list of ints, quantities ordered of each slit width B : int, the width of the mother roll max_widths : int, the maximum number of unique widths we want on any specific layout max_layouts : int, the maximum number of unique layouts we want to fullfill the deckle solution def deckle ( bucket , max_widths = 3 , max_layouts = 3 ): w = bucket [ 'w' ] n = bucket [ 'n' ] L = bucket [ 'L' ] q = bucket [ 'q' ] B = bucket [ 'B' ] widths = [ i + j for i , j in zip ( n , w )] solutions = [] # make the patterns first (pre_sacks) # current_max will account for all max_layouts and anything less for current_max in range ( 1 , max_layouts + 1 ): # our pre_sacks contains the collection of combinations pre_sacks = list ( combinations ( patterns , current_max )) # the sack is what we will send to the lin prog program # we will borrow from column_gen to supplement any pattern # combinations that could use an extra layout (to get to # the max_layouts value) # for sack in pre_sacks: # print(sack) # print() # current_max will account for all max_layouts and anything less for current_max in range ( 1 , max_layouts + 1 ): # our pre_sacks contains the collection of combinations pre_sacks = list ( combinations ( patterns , current_max )) # the sack is what we will send to the lin prog program # we will borrow from column_gen to supplement any pattern # combinations that could use an extra layout (to get to # the max_layouts value) for sack in pre_sacks : sack = list ( sack ) while True : X , val = solveX ( sack , widths , q ) pattern , total = pack_knap ( widths , val , B ) if ( total > 1 ) and ( len ( sack ) < max_layouts ): sack . append ([ pattern , 0 ]) continue break if sum ( X ) > 0 : # print(total) # print(len(sack)) # print(f\"total doffs: {sum(X)}\") for quant , pattern in zip ( X , sack ): if quant > 0 : print ( f \" { quant } , { pattern [ 0 ] } \" ) print () solutions . append ([ X , sack ]) return solutions","title":"Defining Objects"},{"location":"solutions/SOLN_P6_Stock_Cutting/#parallel-processing","text":"For our parallel processing wrapper we introduce a couple more hyperparameters that will allow us to seach through a broader optimization space Secondary: production_targets : list of floats, default [1] . Fraction of each quantity in q to be passed to optimization task edge_trim_allowance : list of ints, default [0] . The amount of edge trim (mm) to add to each end of the mother roll. import math import multiprocessing as mp def make_search ( bucket , max_widths , max_layouts , production_targets = [ 1 ], edge_trim_allowance = [ 0 ], verbose = False ): \"\"\" Handles the parallel search for both schedule_api and front_search_api \"\"\" params = [] goals = [ 1 , 3 , 10 , 100 , 1000 ] # min_patterns will tell us if we can fit all widths into a single mother roll or not min_patterns = math . ceil ( sum ( bucket [ 'w' ]) / bucket [ 'B' ]) # we will mix n match every possible deckle request that comes from the hyperparameters # i.e. max 1 width/layout + max 3 layouts + 99% production + 10mm edge allowance for current_max_width in range ( max_widths + 1 ): for current_max_layout in range ( min_patterns , max_layouts + 1 ): for target in production_targets : for edge in edge_trim_allowance : # only keep combinations that are possible to solve ie the product # of max_layouts and max_widths needs to be greater than the number # of unique widths (bucket['w']) for recursion_goal in goals [: goal ]: if current_max_width * current_max_layout >= len ( bucket [ 'w' ]): # the params list will be used by multiprocessing library to find # each request params . append ([ bucket , current_max_width , current_max_layout , target , edge , recursion_goal , verbiose , opt ]) return params params = make_search ( bucket , 3 , 3 ) len ( params ) 18 We now want to solve the deckle problem 18 times pool = mp . Pool ( mp . cpu_count ()) results = [ pool . apply_async ( deckle , args = ( param [ 0 ], param [ 1 ], param [ 2 ], param [ 3 ], param [ 4 ], param [ 5 ], param [ 6 ], param [ 7 ])) for param in params ] pool . close () while True : if all ([ i . ready () for i in results ]): res = [] for i in results : try : a_result = i . get () . copy () a_result [ 3 ][ 'loss' ] = round ( a_result [ 3 ][ 'loss' ] . astype ( float ), 3 ) res . append ( a_result ) except : pass # search had failed df = pd . DataFrame ( res , columns = [ 'loss' , 'jumbos' , 'inventory' , 'summary' , 'combinations' , 'patterns' , 'target' , 'edge' ]) df [ 'str summ' ] = df [ 'summary' ] . astype ( str ) df = df . sort_values ( 'loss' ) . reset_index ( drop = True ) df = df . drop_duplicates ([ 'str summ' ])[[ 'loss' , 'jumbos' , 'inventory' , 'summary' , 'combinations' , 'patterns' , 'target' , 'edge' ]] . reset_index ( drop = True ) df [ 'loss rank' ] = df [ 'loss' ] . rank ( method = 'first' ) df [ 'jumbo rank' ] = df [ 'jumbos' ] . rank ( method = 'first' ) break df [ 'loss' ] = round ( df [ 'loss' ], 2 ) df = df . sort_values ( 'jumbo rank' ) . reset_index ( drop = True )","title":"Parallel Processing"},{"location":"solutions/SOLN_P6_Stock_Cutting/#what-we-get-from-the-front-end","text":"req = { \"width1\" : \"818\" , \"width2\" : \"1638\" , \"width3\" : \"\" , \"width4\" : \"\" , \"width5\" : \"\" , \"width6\" : \"\" , \"roll1\" : \"473\" , \"roll2\" : \"241\" , \"roll3\" : \"\" , \"roll4\" : \"\" , \"roll5\" : \"\" , \"roll6\" : \"\" , \"neck1\" : \"6\" , \"neck2\" : \"8\" , \"neck3\" : \"\" , \"neck4\" : \"\" , \"neck5\" : \"\" , \"neck6\" : \"\" , \"usable_width\" : \"4160\" , \"put_up\" : \"11700\" , \"doffs_per_jumbo\" : \"1\" , \"max_widths\" : \"2\" , \"max_layouts\" : \"2\" , \"production_targets\" : \"1\" , \"min_prod\" : \"0.99\" , \"max_prod\" : \"1\" , \"edge_allowance\" : \"0\" } how are this json used to populate the appropriate fields for the deka function calls; and how are the results formatted and sent back to the front end def standalone ( req ): \"\"\" Translates the request body into inputs for the cutting stock algorithm \"\"\" max_layouts = int ( req [ \"max_layouts\" ]) max_widths = int ( req [ \"max_widths\" ]) min_prod = float ( req [ \"min_prod\" ]) max_prod = float ( req [ \"max_prod\" ]) # search between min and max in 1% increments if min_prod != max_prod : production_targets = list ( np . arange ( min_prod , max_prod , .01 )) else : production_targets = [ min_prod ] # search with additional edge trim in 1mm increments edge_trim_allowance = int ( req [ \"edge_allowance\" ]) edge_trim_allowance = list ( range ( edge_trim_allowance + 1 )) # build the deckle bucket w = [ int ( req [ i ]) for i in req . keys () if ( 'width' in i ) & ( req [ i ] != '' ) & ( '_width' not in i )] q = [ int ( req [ i ]) for i in req . keys () if ( 'roll' in i ) & ( req [ i ] != '' )] q = [ math . ceil ( i / int ( req [ 'doffs_per_jumbo' ])) for i in q ] n = [ int ( req [ i ]) for i in req . keys () if ( 'neck' in i ) & ( req [ i ] != '' )] B = int ( req [ 'usable_width' ]) L = int ( req [ 'put_up' ]) * int ( req [ 'doffs_per_jumbo' ]) w = [ i + j for i , j in zip ( w , n )] bucket = dict () bucket [ 'w' ] = w bucket [ 'n' ] = n bucket [ 'L' ] = L bucket [ 'q' ] = q bucket [ 'B' ] = B def front_search_api ( req , version , suppress_max_inv = 40 ): # rename this to standalone if version == 1 : max_layouts = req [ \"max_layouts\" ] . split ( ', ' ) max_layouts = [ int ( i ) for i in max_layouts ] max_widths = req [ \"max_widths\" ] . split ( ', ' ) max_widths = [ int ( i ) for i in max_widths ] production_targets = req [ \"production_targets\" ] . split ( ', ' ) production_targets = [ float ( i ) for i in production_targets ] edge_trim_allowance = req [ \"edge_allowance\" ] . split ( ', ' ) edge_trim_allowance = [ int ( i ) for i in edge_trim_allowance ] elif version == 2 : max_layouts = int ( req [ \"max_layouts\" ]) max_widths = int ( req [ \"max_widths\" ]) min_prod = float ( req [ \"min_prod\" ]) max_prod = float ( req [ \"max_prod\" ]) if min_prod != max_prod : production_targets = list ( np . arange ( min_prod , max_prod , .01 )) else : production_targets = [ min_prod ] edge_trim_allowance = int ( req [ \"edge_allowance\" ]) edge_trim_allowance = list ( range ( edge_trim_allowance + 1 )) w = [ int ( req [ i ]) for i in req . keys () if ( 'width' in i ) & ( req [ i ] != '' ) & ( '_width' not in i )] q = [ int ( req [ i ]) for i in req . keys () if ( 'roll' in i ) & ( req [ i ] != '' )] q = [ math . ceil ( i / int ( req [ 'doffs_per_jumbo' ])) for i in q ] n = [ int ( req [ i ]) for i in req . keys () if ( 'neck' in i ) & ( req [ i ] != '' )] B = int ( req [ 'usable_width' ]) L = int ( req [ 'put_up' ]) * int ( req [ 'doffs_per_jumbo' ]) w = [ i + j for i , j in zip ( w , n )] bucket = dict () bucket [ 'w' ] = w bucket [ 'n' ] = n bucket [ 'L' ] = L bucket [ 'q' ] = q bucket [ 'B' ] = B df = make_search ( bucket , max_widths , max_layouts , production_targets , edge_trim_allowance , goal = 3 , opt = 'time' , verbiose = False ) # compute string formatted layouts, inventory levels, and whether targets # were met (%) for bucket_ind in range ( df . shape [ 0 ]): tot_q = 0 for index , layout in enumerate ( df . iloc [ bucket_ind ] [ 'summary' ][ 'layout' ]): txt = '' for width in layout : if layout [ width ] != 0 : txt += str ( layout [ width ]) + 'x' + str ( width ) + ' + ' tot_q += layout [ width ] * df . iloc [ bucket_ind ][ 'summary' ][ 'jumbos' ][ index ] txt = txt [: - 3 ] df . loc [ bucket_ind , 'summary' ] . loc [ index , 'layout' ] = txt # print(tot_q) txt = '' tot_inv = 0 for index , layout in enumerate ( df . iloc [ bucket_ind ][ 'inventory' ]): inventory = df . iloc [ bucket_ind ][ 'inventory' ][ layout ] df . loc [ bucket_ind , 'inv. {} ' . format ( layout )] = inventory txt += str ( int ( inventory )) + 'x' + str ( layout ) + ' + ' tot_inv += inventory txt = txt [: - 3 ] target = f \" { tot_q / ( tot_q - tot_inv ) * 100 : .1f } %\" df . loc [ bucket_ind , 'inventory' ] = txt df . loc [ bucket_ind , 'target' ] = target if suppress_max_inv : df = df . loc [( df [[ col for col in df . columns if 'inv.' in col ]] < suppress_max_inv ) . all ( 1 )] dfjson = df . to_json ( orient = \"records\" ) return dfjson","title":"What we get from the front end"}]}