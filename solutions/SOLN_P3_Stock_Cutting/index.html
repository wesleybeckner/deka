
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.2.3, mkdocs-material-8.1.4">
    
    
      
        <title>The Column Generation Method - Deka</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.bb3983ee.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.e6a45f82.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../extra.css">
    
      <link rel="stylesheet" href="../../styles.css">
    
    <script>__md_scope=new URL("../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      
  


  
  


  <script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-114664473-1","auto"),ga("set","anonymizeIp",!0),ga("send","pageview"),document.addEventListener("DOMContentLoaded",function(){document.forms.search&&document.forms.search.query.addEventListener("blur",function(){var e;this.value&&(e=document.location.pathname,ga("send","pageview",e+"?q="+this.value))}),"undefined"!=typeof location$&&location$.subscribe(function(e){ga("send","pageview",e.pathname)})})</script>
  <script async src="https://www.google-analytics.com/analytics.js"></script>


    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="" data-md-color-accent="">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#stock-cutting-part-3-the-column-generation-method" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Deka" class="md-header__button md-logo" aria-label="Deka" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Deka
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              The Column Generation Method
            
          </span>
        </div>
      </div>
    </div>
    
      <form class="md-header__option" data-md-component="palette">
        
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="" data-md-color-accent=""  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
          
            <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4zM7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
            </label>
          
        
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="" data-md-color-accent=""  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
          
            <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3z"/></svg>
            </label>
          
        
      </form>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Deka" class="md-nav__button md-logo" aria-label="Deka" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Deka
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        About
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          Solutions
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Solutions" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          Solutions
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../SOLN_P1_Stock_Cutting/" class="md-nav__link">
        The Knapsack Problem
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../SOLN_P2_Stock_Cutting/" class="md-nav__link">
        Finding More Patterns
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          The Column Generation Method
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        The Column Generation Method
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#10-import-functions-and-libraries" class="md-nav__link">
    1.0: Import Functions and Libraries
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#20-the-restricted-master-problem-rmp" class="md-nav__link">
    2.0 The Restricted Master Problem (RMP)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#30-the-column-generation-subproblem-cgsp" class="md-nav__link">
    3.0 The Column Generation Subproblem (CGSP)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#40-functions" class="md-nav__link">
    4.0 Functions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#50-all-together-now" class="md-nav__link">
    5.0 All Together Now
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          Exercises
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Exercises" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          Exercises
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../exercises/P1_Stock_Cutting/" class="md-nav__link">
        The Knapsack Problem
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../exercises/P2_Stock_Cutting/" class="md-nav__link">
        Finding More Patterns
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../exercises/P3_Stock_Cutting/" class="md-nav__link">
        The Column Generation Method
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#10-import-functions-and-libraries" class="md-nav__link">
    1.0: Import Functions and Libraries
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#20-the-restricted-master-problem-rmp" class="md-nav__link">
    2.0 The Restricted Master Problem (RMP)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#30-the-column-generation-subproblem-cgsp" class="md-nav__link">
    3.0 The Column Generation Subproblem (CGSP)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#40-functions" class="md-nav__link">
    4.0 Functions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#50-all-together-now" class="md-nav__link">
    5.0 All Together Now
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                

<p><a href="https://colab.research.google.com/github/wesleybeckner/deka/blob/main/notebooks/solutions/SOLN_P3_Stock_Cutting.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a></p>
<h1 id="stock-cutting-part-3-the-column-generation-method">Stock Cutting Part 3:<br> The Column Generation Method<a class="headerlink" href="#stock-cutting-part-3-the-column-generation-method" title="Permanent link">&para;</a></h1>
<p><br></p>
<hr />
<p><br></p>
<p>In this project notebook we'll be combining our dynamic program from the knapsack problem with a strategy called the <em>column generation method</em></p>
<p><br></p>
<hr />
<h2 id="10-import-functions-and-libraries">1.0: Import Functions and Libraries<a class="headerlink" href="#10-import-functions-and-libraries" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>

<span class="k">def</span> <span class="nf">seed_patterns</span><span class="p">(</span><span class="n">_widths</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">max_unique_layouts</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">patterns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">current_max</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_unique_layouts</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">pre_sacks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">_widths</span><span class="p">,</span> <span class="n">current_max</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">widths</span> <span class="ow">in</span> <span class="n">pre_sacks</span><span class="p">:</span>
            <span class="n">new</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">widths</span><span class="p">:</span>
                <span class="n">new</span> <span class="o">+=</span> <span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">W</span><span class="o">/</span><span class="n">w</span><span class="p">)</span>
            <span class="n">widths</span> <span class="o">=</span> <span class="n">new</span>

            <span class="n">t</span> <span class="o">=</span> <span class="n">initt</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">widths</span><span class="p">)</span>
            <span class="n">best</span> <span class="o">=</span> <span class="n">knapsack</span><span class="p">(</span><span class="n">widths</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">W</span> <span class="o">-</span> <span class="n">best</span>
            <span class="n">sack</span> <span class="o">=</span> <span class="n">reconstruct</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">),</span> <span class="n">W</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">widths</span><span class="p">)</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sack</span><span class="p">)])</span>
            <span class="n">patterns</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pattern</span><span class="p">,</span> <span class="n">loss</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">patterns</span>

<span class="k">def</span> <span class="nf">initt</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">W</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">knapsack</span><span class="p">(</span><span class="n">wt</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="c1"># n, w will be the row, column of our table</span>
    <span class="c1"># solve the basecase. </span>
    <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">elif</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">w</span><span class="p">]</span>

    <span class="c1"># now include the conditionals</span>
    <span class="k">if</span> <span class="n">wt</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">:</span>
        <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="n">knapsack</span><span class="p">(</span><span class="n">wt</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span>
            <span class="n">knapsack</span><span class="p">(</span><span class="n">wt</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">w</span><span class="o">-</span><span class="n">wt</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">val</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">w</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">wt</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">w</span><span class="p">:</span>
        <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">knapsack</span><span class="p">(</span><span class="n">wt</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">w</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">reconstruct</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">wt</span><span class="p">):</span>
    <span class="n">recon</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">W</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">W</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">recon</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">W</span> <span class="o">-</span> <span class="n">wt</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="c1"># move columns in table lookup</span>
        <span class="k">if</span> <span class="n">W</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">continue</span>
    <span class="k">return</span> <span class="n">recon</span>

<span class="k">def</span> <span class="nf">test_small_bag</span><span class="p">():</span>
    <span class="c1"># the problem parameters</span>
    <span class="n">val</span> <span class="o">=</span> <span class="p">[</span><span class="mi">60</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
    <span class="n">wt</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">W</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="c1"># the known solution</span>
    <span class="n">max_val</span> <span class="o">=</span> <span class="mi">80</span>
    <span class="n">max_items</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">initt</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="n">best</span> <span class="o">=</span> <span class="n">knapsack</span><span class="p">(</span><span class="n">wt</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">sack</span> <span class="o">=</span> <span class="n">reconstruct</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">W</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">wt</span><span class="p">)</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sack</span><span class="p">)])</span>

    <span class="k">assert</span> <span class="n">best</span> <span class="o">==</span> <span class="n">max_val</span><span class="p">,</span> <span class="s2">&quot;Optimal value not found&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimal value found&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">pattern</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="n">max_items</span><span class="p">,</span> <span class="s2">&quot;Optimal items not found&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimal items found&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_val_weight_equality</span><span class="p">():</span>
    <span class="c1"># the problem parameters</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">wt</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
    <span class="n">W</span> <span class="o">=</span> <span class="mi">14</span>

    <span class="c1"># the known solution</span>
    <span class="n">max_val</span> <span class="o">=</span> <span class="mi">14</span>
    <span class="n">max_items</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">initt</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="n">best</span> <span class="o">=</span> <span class="n">knapsack</span><span class="p">(</span><span class="n">wt</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">sack</span> <span class="o">=</span> <span class="n">reconstruct</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">W</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">wt</span><span class="p">)</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sack</span><span class="p">)])</span>

    <span class="k">assert</span> <span class="n">best</span> <span class="o">==</span> <span class="n">max_val</span><span class="p">,</span> <span class="s2">&quot;Optimal value not found&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimal value found&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">pattern</span> <span class="o">==</span> <span class="n">max_items</span><span class="p">,</span> <span class="s2">&quot;Optimal items not found&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimal items found&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">test_small_bag</span><span class="p">()</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Optimal value found
Optimal items found
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">test_val_weight_equality</span><span class="p">()</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Optimal value found
Optimal items found
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">_widths</span> <span class="o">=</span> <span class="p">[</span><span class="mi">170</span><span class="p">,</span> <span class="mi">280</span><span class="p">,</span> <span class="mi">320</span><span class="p">]</span>
<span class="n">W</span> <span class="o">=</span> <span class="mi">4000</span>
<span class="n">max_unique_layouts</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">seed_patterns</span><span class="p">(</span><span class="n">_widths</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>[[Counter({170: 23}), 90],
 [Counter({280: 14}), 80],
 [Counter({320: 12}), 160],
 [Counter({170: 12, 280: 7}), 0],
 [Counter({170: 16, 320: 4}), 0],
 [Counter({280: 12, 320: 2}), 0],
 [Counter({170: 12, 280: 7}), 0]]
</code></pre></div>

<h2 id="20-the-restricted-master-problem-rmp">2.0 The Restricted Master Problem (RMP)<a class="headerlink" href="#20-the-restricted-master-problem-rmp" title="Permanent link">&para;</a></h2>
<p>first we create our naieve solutions (restrict 1 layout per pattern)</p>
<div class="codehilite"><pre><span></span><code><span class="n">q</span> <span class="o">=</span> <span class="p">[</span><span class="mi">80</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
<span class="n">widths</span> <span class="o">=</span> <span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="n">W</span> <span class="o">=</span> <span class="mi">15</span>

<span class="n">patterns</span> <span class="o">=</span> <span class="n">seed_patterns</span><span class="p">(</span><span class="n">widths</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">max_unique_layouts</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">patterns</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>[[Counter({4: 3}), 3], [Counter({6: 2}), 3], [Counter({7: 2}), 1]]
</code></pre></div>

<p>Then we perform the linear programming task. </p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">linprog</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">ceil</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">lhs_ineq</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>

    <span class="c1"># inset will be our full build of a given &quot;pattern&quot;</span>
    <span class="n">inset</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">width</span> <span class="ow">in</span> <span class="n">widths</span><span class="p">:</span>

        <span class="c1"># try to access the slitwidth counts, otherwise</span>
        <span class="c1"># it means none of that slitwidth was included </span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">inset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">width</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">inset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># add inset to the set of equations (patterns)        </span>
    <span class="n">lhs_ineq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inset</span><span class="p">)</span>
<span class="n">lhs_ineq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lhs_ineq</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

<span class="c1"># rhs is the min orders we need for each slitwidth</span>
<span class="n">rhs_ineq</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">q</span><span class="p">]</span>

<span class="c1"># min x1 + x2 + .... Xn</span>
<span class="n">obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lhs_ineq</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

<span class="c1"># linprog will determine the minimum number we need</span>
<span class="c1"># of each pattern</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">linprog</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span>
        <span class="n">A_ub</span><span class="o">=</span><span class="n">lhs_ineq</span><span class="p">,</span>
        <span class="n">b_ub</span><span class="o">=</span><span class="n">rhs_ineq</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;revised simplex&quot;</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="n">ceil</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total doffs: </span><span class="si">{</span><span class="nb">sum</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>[27, 25, 50]
total doffs: 102
</code></pre></div>

<p>These values of <code>X</code> are the minimum doffs we need to fulfill our order quantities <code>q</code> given a set of patterns, <code>patterns</code>.</p>
<p>The trick we next employee, is we determine how costly each width is to our solution. We do this by solving the dual variables of the linear program. </p>
<p>The dual of a given linear program (LP) is another LP that is derived from the original (the primal) LP. Algorithmically this looks like the following:</p>
<ol>
<li>Each variable in the primal LP becomes a constraint in the dual LP</li>
<li>Each constraint in the primal LP becomes a variable in the dual LP</li>
<li>The objective direction is inversed – maximum in the primal becomes minimum in the dual and vice versa</li>
</ol>
<p>Notice below we switch the parameter fields for <code>c</code> and <code>b_ub</code> (the coefficients of the linear objective function and the linear constraint vector). And we take the negative transpose of our system of equations <code>A_ub</code>. </p>
<div class="codehilite"><pre><span></span><code><span class="n">dual_problem</span> <span class="o">=</span> <span class="n">linprog</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">rhs_ineq</span><span class="p">,</span>
        <span class="n">A_ub</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lhs_ineq</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
        <span class="n">b_ub</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;revised simplex&quot;</span><span class="p">)</span>
<span class="n">val</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dual_problem</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]]</span>
<span class="n">val</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>[0.3333333333333333, 0.5, 0.5]
</code></pre></div>

<p>Roughly, this outcome is similar to the number of doffs dedicated to each width, normalized by the quantity ordered for each width. (Note that this comparison is only approximately true but is meant to give a conceptual guide).</p>
<div class="codehilite"><pre><span></span><code><span class="p">[</span><span class="n">i</span><span class="o">/</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">q</span><span class="p">)]</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>[0.3375, 0.5, 0.5]
</code></pre></div>

<h2 id="30-the-column-generation-subproblem-cgsp">3.0 The Column Generation Subproblem (CGSP)<a class="headerlink" href="#30-the-column-generation-subproblem-cgsp" title="Permanent link">&para;</a></h2>
<p>Ok. So what was that dual variable stuff all about? We are going to use the dual variable to update the value of each width. That's right, the behavior of each width in reference to the final doff quantities, <code>X</code> is used to bias the knapsack problem to give us a pattern that gives preferential treatment to the troublesome widths!</p>
<div class="codehilite"><pre><span></span><code><span class="n">wt</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="n">W</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">new_wt</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">new_val</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">wt</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="n">new_wt</span> <span class="o">+=</span> <span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">W</span><span class="o">/</span><span class="n">w</span><span class="p">)</span>
    <span class="n">new_val</span> <span class="o">+=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">W</span><span class="o">/</span><span class="n">w</span><span class="p">)</span>
<span class="n">wt</span> <span class="o">=</span> <span class="n">new_wt</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">new_val</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">initt</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
<span class="n">best</span> <span class="o">=</span> <span class="n">knapsack</span><span class="p">(</span><span class="n">wt</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span>
<span class="n">loss</span> <span class="o">=</span> <span class="n">W</span> <span class="o">-</span> <span class="n">best</span>
<span class="n">sack</span> <span class="o">=</span> <span class="n">reconstruct</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">W</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">wt</span><span class="p">)</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="n">wt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sack</span><span class="p">)])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sack</span><span class="p">)])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">worth</span><span class="p">,</span> <span class="n">multiple</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">worth</span> <span class="o">*</span> <span class="n">multiple</span>
<span class="n">total</span> <span class="o">&gt;</span> <span class="mi">1</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Counter({4: 2, 6: 1})
Counter({0.3333333333333333: 2, 0.5: 1})





True
</code></pre></div>

<p>The last conditional above, <code>total &gt;</code> is our criteria for adding the new width to the growing host of patterns to then send to the RMP. If the total worth of the knapsack is greater than 1, this means our RMP will return a new solution with the added pattern that will result in overall fewer doffs.</p>
<div class="codehilite"><pre><span></span><code><span class="n">patterns</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pattern</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="n">patterns</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>[[Counter({4: 3}), 3],
 [Counter({6: 2}), 3],
 [Counter({7: 2}), 1],
 [Counter({4: 2, 6: 1}), None]]
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">lhs_ineq</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>

    <span class="c1"># inset will be our full build of a given &quot;pattern&quot;</span>
    <span class="n">inset</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">width</span> <span class="ow">in</span> <span class="n">widths</span><span class="p">:</span>

        <span class="c1"># try to access the slitwidth counts, otherwise</span>
        <span class="c1"># it means none of that slitwidth was included </span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">inset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">width</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">inset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># add inset to the set of equations (patterns)        </span>
    <span class="n">lhs_ineq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inset</span><span class="p">)</span>

<span class="n">lhs_ineq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lhs_ineq</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="c1"># rhs is the min orders we need for each slitwidth</span>
<span class="n">rhs_ineq</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">q</span><span class="p">]</span>

<span class="c1"># min x1 + x2 + .... Xn</span>
<span class="n">obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lhs_ineq</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

<span class="c1"># linprog will determine the minimum number we need</span>
<span class="c1"># of each pattern</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">linprog</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span>
        <span class="n">A_ub</span><span class="o">=</span><span class="n">lhs_ineq</span><span class="p">,</span>
        <span class="n">b_ub</span><span class="o">=</span><span class="n">rhs_ineq</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;revised simplex&quot;</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="n">ceil</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>[0, 5, 50, 41]
</code></pre></div>

<p>we see that the total number of doffs is reduced from 102 to 96!</p>
<div class="codehilite"><pre><span></span><code><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total doffs: </span><span class="si">{</span><span class="nb">sum</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>total doffs: 96
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">dual_problem</span> <span class="o">=</span> <span class="n">linprog</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">rhs_ineq</span><span class="p">,</span>
        <span class="n">A_ub</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lhs_ineq</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
        <span class="n">b_ub</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;revised simplex&quot;</span><span class="p">)</span>
<span class="n">val</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dual_problem</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]]</span>
<span class="n">val</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>[0.25, 0.5, 0.5]
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">wt</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="n">W</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">new_wt</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">new_val</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">wt</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="n">new_wt</span> <span class="o">+=</span> <span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">W</span><span class="o">/</span><span class="n">w</span><span class="p">)</span>
    <span class="n">new_val</span> <span class="o">+=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">W</span><span class="o">/</span><span class="n">w</span><span class="p">)</span>
<span class="n">wt</span> <span class="o">=</span> <span class="n">new_wt</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">new_val</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">initt</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
<span class="n">best</span> <span class="o">=</span> <span class="n">knapsack</span><span class="p">(</span><span class="n">wt</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span>
<span class="n">loss</span> <span class="o">=</span> <span class="n">W</span> <span class="o">-</span> <span class="n">best</span>
<span class="n">sack</span> <span class="o">=</span> <span class="n">reconstruct</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">W</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">wt</span><span class="p">)</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="n">wt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sack</span><span class="p">)])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sack</span><span class="p">)])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">worth</span><span class="p">,</span> <span class="n">multiple</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">worth</span> <span class="o">*</span> <span class="n">multiple</span>
<span class="n">total</span> <span class="o">&gt;</span> <span class="mi">1</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Counter({4: 2, 6: 1})
Counter({0.25: 2, 0.5: 1})





False
</code></pre></div>

<p>In this case, the knapsack problem does not produce a knapsack with a value greater than 1, and so we discontinue our CGSP!</p>
<div class="codehilite"><pre><span></span><code><span class="n">total</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>1.0
</code></pre></div>

<h2 id="40-functions">4.0 Functions<a class="headerlink" href="#40-functions" title="Permanent link">&para;</a></h2>
<p>Let's bundle our code into some functions</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">linprog</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">ceil</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">solveX</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="n">lhs_ineq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>

        <span class="c1"># inset will be our full build of a given &quot;pattern&quot;</span>
        <span class="n">inset</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">width</span> <span class="ow">in</span> <span class="n">widths</span><span class="p">:</span>

            <span class="c1"># try to access the slitwidth counts, otherwise</span>
            <span class="c1"># it means none of that slitwidth was included </span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">inset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">width</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">inset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># add inset to the set of equations (patterns)        </span>
        <span class="n">lhs_ineq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inset</span><span class="p">)</span>
    <span class="n">lhs_ineq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lhs_ineq</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1"># rhs is the min orders we need for each slitwidth</span>
    <span class="n">rhs_ineq</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">q</span><span class="p">]</span>

    <span class="c1"># min x1 + x2 + .... Xn</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lhs_ineq</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="c1"># linprog will determine the minimum number we need</span>
    <span class="c1"># of each pattern</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">linprog</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span>
            <span class="n">A_ub</span><span class="o">=</span><span class="n">lhs_ineq</span><span class="p">,</span>
            <span class="n">b_ub</span><span class="o">=</span><span class="n">rhs_ineq</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;revised simplex&quot;</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="n">ceil</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]]</span>


    <span class="n">dual_problem</span> <span class="o">=</span> <span class="n">linprog</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">rhs_ineq</span><span class="p">,</span>
        <span class="n">A_ub</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lhs_ineq</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
        <span class="n">b_ub</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;revised simplex&quot;</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dual_problem</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">val</span>

<span class="k">def</span> <span class="nf">pack_knap</span><span class="p">(</span><span class="n">wt</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">W</span><span class="p">):</span>
    <span class="n">new_wt</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_val</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">wt</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">new_wt</span> <span class="o">+=</span> <span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">W</span><span class="o">/</span><span class="n">w</span><span class="p">)</span>
        <span class="n">new_val</span> <span class="o">+=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">W</span><span class="o">/</span><span class="n">w</span><span class="p">)</span>
    <span class="n">wt</span> <span class="o">=</span> <span class="n">new_wt</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">new_val</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">initt</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="n">best</span> <span class="o">=</span> <span class="n">knapsack</span><span class="p">(</span><span class="n">wt</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">W</span> <span class="o">-</span> <span class="n">best</span>
    <span class="n">sack</span> <span class="o">=</span> <span class="n">reconstruct</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">W</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">wt</span><span class="p">)</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="n">wt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sack</span><span class="p">)])</span>

    <span class="n">value</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sack</span><span class="p">)])</span>


    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">worth</span><span class="p">,</span> <span class="n">multiple</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">worth</span> <span class="o">*</span> <span class="n">multiple</span>
    <span class="k">return</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">total</span>
</code></pre></div>

<p>Starting over with the former example...</p>
<p>We seed our patterns with the naive solutions</p>
<div class="codehilite"><pre><span></span><code><span class="n">q</span> <span class="o">=</span> <span class="p">[</span><span class="mi">80</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
<span class="n">widths</span> <span class="o">=</span> <span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="n">W</span> <span class="o">=</span> <span class="mi">15</span>

<span class="n">patterns</span> <span class="o">=</span> <span class="n">seed_patterns</span><span class="p">(</span><span class="n">widths</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">max_unique_layouts</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">patterns</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>[[Counter({4: 3}), 3], [Counter({6: 2}), 3], [Counter({7: 2}), 1]]
</code></pre></div>

<p>We solve the RMP</p>
<div class="codehilite"><pre><span></span><code><span class="n">X</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">solveX</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>102
[27, 25, 50] [0.3333333333333333, 0.5, 0.5]
</code></pre></div>

<p>We solve the CGSP</p>
<div class="codehilite"><pre><span></span><code><span class="n">pattern</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="n">pack_knap</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">total</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">total</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Counter({4: 2, 6: 1}) 1.1666666666666665
True
</code></pre></div>

<p>Since the value is greater than 1 we add the pattern to our linprog and solve the RMP again</p>
<div class="codehilite"><pre><span></span><code><span class="n">patterns</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pattern</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">X</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">solveX</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

<span class="n">pattern</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="n">pack_knap</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">total</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">total</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>96
[0, 5, 50, 41] [0.25, 0.5, 0.5]
Counter({4: 2, 6: 1}) 1.0
False
</code></pre></div>

<p>We exit when we can no longer find a pattern that would improve the RMP</p>
<h2 id="50-all-together-now">5.0 All Together Now<a class="headerlink" href="#50-all-together-now" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span><code><span class="n">q</span> <span class="o">=</span> <span class="p">[</span><span class="mi">80</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
<span class="n">widths</span> <span class="o">=</span> <span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="n">W</span> <span class="o">=</span> <span class="mi">15</span>

<span class="n">patterns</span> <span class="o">=</span> <span class="n">seed_patterns</span><span class="p">(</span><span class="n">widths</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">max_unique_layouts</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">solveX</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">pattern</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="n">pack_knap</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">total</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">patterns</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pattern</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">continue</span>
    <span class="k">break</span>

<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total doffs: </span><span class="si">{</span><span class="nb">sum</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">quant</span><span class="p">,</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">patterns</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">quant</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">quant</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>total doffs: 96

5, Counter({6: 2})
50, Counter({7: 2})
41, Counter({4: 2, 6: 1})
</code></pre></div>

              
            </article>
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        
        <a href="../SOLN_P2_Stock_Cutting/" class="md-footer__link md-footer__link--prev" aria-label="Previous: Finding More Patterns" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              Finding More Patterns
            </div>
          </div>
        </a>
      
      
        
        <a href="../../exercises/P1_Stock_Cutting/" class="md-footer__link md-footer__link--next" aria-label="Next: The Knapsack Problem" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              The Knapsack Problem
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../../assets/javascripts/workers/search.361d90f1.min.js"}</script>
    
    
      <script src="../../assets/javascripts/bundle.289a2a4b.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      
    
  </body>
</html>